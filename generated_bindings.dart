// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// !\brief Open a descriptor, allocating storage for the underlying image
  ///
  /// Returns a descriptor for storing an image of the given format. The
  /// storage for the descriptor is allocated on the heap.
  ///
  /// \param[in]    img       Pointer to storage for descriptor. If this parameter
  /// is NULL, the storage for the descriptor will be
  /// allocated on the heap.
  /// \param[in]    fmt       Format for the image
  /// \param[in]    d_w       Width of the image. Must not exceed 0x08000000
  /// (2^27).
  /// \param[in]    d_h       Height of the image. Must not exceed 0x08000000
  /// (2^27).
  /// \param[in]    align     Alignment, in bytes, of the image buffer and
  /// each row in the image (stride). Must not exceed
  /// 65536.
  ///
  /// \return Returns a pointer to the initialized image descriptor. If the img
  /// parameter is non-null, the value of the img parameter will be
  /// returned.
  ffi.Pointer<vpx_image_t> vpx_img_alloc(
    ffi.Pointer<vpx_image_t> img,
    vpx_img_fmt fmt,
    int d_w,
    int d_h,
    int align,
  ) {
    return _vpx_img_alloc(
      img,
      fmt.value,
      d_w,
      d_h,
      align,
    );
  }

  late final _vpx_img_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_image_t> Function(
              ffi.Pointer<vpx_image_t>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('vpx_img_alloc');
  late final _vpx_img_alloc = _vpx_img_allocPtr.asFunction<
      ffi.Pointer<vpx_image_t> Function(
          ffi.Pointer<vpx_image_t>, int, int, int, int)>();

  /// !\brief Open a descriptor, using existing storage for the underlying image
  ///
  /// Returns a descriptor for storing an image of the given format. The
  /// storage for descriptor has been allocated elsewhere, and a descriptor is
  /// desired to "wrap" that storage.
  ///
  /// \param[in]    img           Pointer to storage for descriptor. If this
  /// parameter is NULL, the storage for the descriptor
  /// will be allocated on the heap.
  /// \param[in]    fmt           Format for the image
  /// \param[in]    d_w           Width of the image. Must not exceed 0x08000000
  /// (2^27).
  /// \param[in]    d_h           Height of the image. Must not exceed 0x08000000
  /// (2^27).
  /// \param[in]    stride_align  Alignment, in bytes, of each row in the image
  /// (stride). Must not exceed 65536.
  /// \param[in]    img_data      Storage to use for the image
  ///
  /// \return Returns a pointer to the initialized image descriptor. If the img
  /// parameter is non-null, the value of the img parameter will be
  /// returned.
  ffi.Pointer<vpx_image_t> vpx_img_wrap(
    ffi.Pointer<vpx_image_t> img,
    vpx_img_fmt fmt,
    int d_w,
    int d_h,
    int stride_align,
    ffi.Pointer<ffi.UnsignedChar> img_data,
  ) {
    return _vpx_img_wrap(
      img,
      fmt.value,
      d_w,
      d_h,
      stride_align,
      img_data,
    );
  }

  late final _vpx_img_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_image_t> Function(
              ffi.Pointer<vpx_image_t>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedChar>)>>('vpx_img_wrap');
  late final _vpx_img_wrap = _vpx_img_wrapPtr.asFunction<
      ffi.Pointer<vpx_image_t> Function(ffi.Pointer<vpx_image_t>, int, int, int,
          int, ffi.Pointer<ffi.UnsignedChar>)>();

  /// !\brief Set the rectangle identifying the displayed portion of the image
  ///
  /// Updates the displayed rectangle (aka viewport) on the image surface to
  /// match the specified coordinates and size. Specifically, sets img->d_w,
  /// img->d_h, and elements of the img->planes[] array.
  ///
  /// \param[in]    img       Image descriptor
  /// \param[in]    x         leftmost column
  /// \param[in]    y         topmost row
  /// \param[in]    w         width
  /// \param[in]    h         height
  ///
  /// \return 0 if the requested rectangle is valid, nonzero (-1) otherwise.
  int vpx_img_set_rect(
    ffi.Pointer<vpx_image_t> img,
    int x,
    int y,
    int w,
    int h,
  ) {
    return _vpx_img_set_rect(
      img,
      x,
      y,
      w,
      h,
    );
  }

  late final _vpx_img_set_rectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<vpx_image_t>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('vpx_img_set_rect');
  late final _vpx_img_set_rect = _vpx_img_set_rectPtr
      .asFunction<int Function(ffi.Pointer<vpx_image_t>, int, int, int, int)>();

  /// !\brief Flip the image vertically (top for bottom)
  ///
  /// Adjusts the image descriptor's pointers and strides to make the image
  /// be referenced upside-down.
  ///
  /// \param[in]    img       Image descriptor
  void vpx_img_flip(
    ffi.Pointer<vpx_image_t> img,
  ) {
    return _vpx_img_flip(
      img,
    );
  }

  late final _vpx_img_flipPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<vpx_image_t>)>>(
          'vpx_img_flip');
  late final _vpx_img_flip =
      _vpx_img_flipPtr.asFunction<void Function(ffi.Pointer<vpx_image_t>)>();

  /// !\brief Close an image descriptor
  ///
  /// Frees all allocated storage associated with an image descriptor.
  ///
  /// \param[in]    img       Image descriptor
  void vpx_img_free(
    ffi.Pointer<vpx_image_t> img,
  ) {
    return _vpx_img_free(
      img,
    );
  }

  late final _vpx_img_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<vpx_image_t>)>>(
          'vpx_img_free');
  late final _vpx_img_free =
      _vpx_img_freePtr.asFunction<void Function(ffi.Pointer<vpx_image_t>)>();

  /// !\brief Return the version information (as an integer)
  ///
  /// Returns a packed encoding of the library version number. This will only
  /// include
  /// the major.minor.patch component of the version number. Note that this encoded
  /// value should be accessed through the macros provided, as the encoding may
  /// change
  /// in the future.
  int vpx_codec_version() {
    return _vpx_codec_version();
  }

  late final _vpx_codec_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vpx_codec_version');
  late final _vpx_codec_version =
      _vpx_codec_versionPtr.asFunction<int Function()>();

  /// !\brief Return the version information (as a string)
  ///
  /// Returns a printable string containing the full library version number. This
  /// may
  /// contain additional text following the three digit version number, as to
  /// indicate
  /// release candidates, prerelease versions, etc.
  ffi.Pointer<ffi.Char> vpx_codec_version_str() {
    return _vpx_codec_version_str();
  }

  late final _vpx_codec_version_strPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'vpx_codec_version_str');
  late final _vpx_codec_version_str =
      _vpx_codec_version_strPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// !\brief Return the version information (as a string)
  ///
  /// Returns a printable "extra string". This is the component of the string
  /// returned
  /// by vpx_codec_version_str() following the three digit version number.
  ffi.Pointer<ffi.Char> vpx_codec_version_extra_str() {
    return _vpx_codec_version_extra_str();
  }

  late final _vpx_codec_version_extra_strPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'vpx_codec_version_extra_str');
  late final _vpx_codec_version_extra_str = _vpx_codec_version_extra_strPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// !\brief Return the build configuration
  ///
  /// Returns a printable string containing an encoded version of the build
  /// configuration. This may be useful to vpx support.
  ffi.Pointer<ffi.Char> vpx_codec_build_config() {
    return _vpx_codec_build_config();
  }

  late final _vpx_codec_build_configPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'vpx_codec_build_config');
  late final _vpx_codec_build_config =
      _vpx_codec_build_configPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// !\brief Return the name for a given interface
  ///
  /// Returns a human readable string for name of the given codec interface.
  ///
  /// \param[in]    iface     Interface pointer
  ffi.Pointer<ffi.Char> vpx_codec_iface_name(
    ffi.Pointer<vpx_codec_iface_t> iface,
  ) {
    return _vpx_codec_iface_name(
      iface,
    );
  }

  late final _vpx_codec_iface_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<vpx_codec_iface_t>)>>('vpx_codec_iface_name');
  late final _vpx_codec_iface_name = _vpx_codec_iface_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<vpx_codec_iface_t>)>();

  /// !\brief Convert error number to printable string
  ///
  /// Returns a human readable string for the last error returned by the
  /// algorithm. The returned error will be one line and will not contain
  /// any newline characters.
  ///
  ///
  /// \param[in]    err     Error number.
  ffi.Pointer<ffi.Char> vpx_codec_err_to_string(
    vpx_codec_err_t err,
  ) {
    return _vpx_codec_err_to_string(
      err.value,
    );
  }

  late final _vpx_codec_err_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'vpx_codec_err_to_string');
  late final _vpx_codec_err_to_string = _vpx_codec_err_to_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// !\brief Retrieve error synopsis for codec context
  ///
  /// Returns a human readable string for the last error returned by the
  /// algorithm. The returned error will be one line and will not contain
  /// any newline characters.
  ///
  ///
  /// \param[in]    ctx     Pointer to this instance's context.
  ffi.Pointer<ffi.Char> vpx_codec_error(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
  ) {
    return _vpx_codec_error(
      ctx,
    );
  }

  late final _vpx_codec_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<vpx_codec_ctx_t>)>>('vpx_codec_error');
  late final _vpx_codec_error = _vpx_codec_errorPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<vpx_codec_ctx_t>)>();

  /// !\brief Retrieve detailed error information for codec context
  ///
  /// Returns a human readable string providing detailed information about
  /// the last error. The returned string is only valid until the next
  /// vpx_codec_* function call (except vpx_codec_error and
  /// vpx_codec_error_detail) on the codec context.
  ///
  /// \param[in]    ctx     Pointer to this instance's context.
  ///
  /// \retval NULL
  /// No detailed information is available.
  ffi.Pointer<ffi.Char> vpx_codec_error_detail(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
  ) {
    return _vpx_codec_error_detail(
      ctx,
    );
  }

  late final _vpx_codec_error_detailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<vpx_codec_ctx_t>)>>('vpx_codec_error_detail');
  late final _vpx_codec_error_detail = _vpx_codec_error_detailPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<vpx_codec_ctx_t>)>();

  /// !\brief Destroy a codec instance
  ///
  /// Destroys a codec context, freeing any associated memory buffers.
  ///
  /// \param[in] ctx   Pointer to this instance's context
  ///
  /// \retval #VPX_CODEC_OK
  /// The codec instance has been destroyed.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// ctx is a null pointer.
  /// \retval #VPX_CODEC_ERROR
  /// Codec context not initialized.
  vpx_codec_err_t vpx_codec_destroy(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_destroy(
      ctx,
    ));
  }

  late final _vpx_codec_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>)>>('vpx_codec_destroy');
  late final _vpx_codec_destroy = _vpx_codec_destroyPtr
      .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>)>();

  /// !\brief Get the capabilities of an algorithm.
  ///
  /// Retrieves the capabilities bitfield from the algorithm's interface.
  ///
  /// \param[in] iface   Pointer to the algorithm interface
  int vpx_codec_get_caps(
    ffi.Pointer<vpx_codec_iface_t> iface,
  ) {
    return _vpx_codec_get_caps(
      iface,
    );
  }

  late final _vpx_codec_get_capsPtr = _lookup<
      ffi.NativeFunction<
          vpx_codec_caps_t Function(
              ffi.Pointer<vpx_codec_iface_t>)>>('vpx_codec_get_caps');
  late final _vpx_codec_get_caps = _vpx_codec_get_capsPtr
      .asFunction<int Function(ffi.Pointer<vpx_codec_iface_t>)>();

  /// !\brief Control algorithm
  ///
  /// This function is used to exchange algorithm specific data with the codec
  /// instance. This can be used to implement features specific to a particular
  /// algorithm.
  ///
  /// This wrapper function dispatches the request to the helper function
  /// associated with the given ctrl_id. It tries to call this function
  /// transparently, but will return #VPX_CODEC_ERROR if the request could not
  /// be dispatched.
  ///
  /// Note that this function should not be used directly. Call the
  /// #vpx_codec_control wrapper macro instead.
  ///
  /// \param[in]     ctx              Pointer to this instance's context
  /// \param[in]     ctrl_id          Algorithm specific control identifier
  ///
  /// \retval #VPX_CODEC_OK
  /// The control request was processed.
  /// \retval #VPX_CODEC_ERROR
  /// The control request was not processed.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// The data was not valid.
  vpx_codec_err_t vpx_codec_control_(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    int ctrl_id,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_(
      ctx,
      ctrl_id,
    ));
  }

  late final _vpx_codec_control_Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>, ffi.Int)>>('vpx_codec_control_');
  late final _vpx_codec_control_ = _vpx_codec_control_Ptr
      .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int)>();

  /// !\cond */
  /// /*!\brief vp8 decoder control function parameter type
  ///
  /// defines the data type for each of VP8 decoder control function requires
  vpx_codec_err_t vpx_codec_control_VP8_SET_REFERENCE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_ref_frame_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8_SET_REFERENCE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8_SET_REFERENCEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_ref_frame_t>)>>(
      'vpx_codec_control_VP8_SET_REFERENCE');
  late final _vpx_codec_control_VP8_SET_REFERENCE =
      _vpx_codec_control_VP8_SET_REFERENCEPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_ref_frame_t>)>();

  vpx_codec_err_t vpx_codec_control_VP8_COPY_REFERENCE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_ref_frame_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8_COPY_REFERENCE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8_COPY_REFERENCEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_ref_frame_t>)>>(
      'vpx_codec_control_VP8_COPY_REFERENCE');
  late final _vpx_codec_control_VP8_COPY_REFERENCE =
      _vpx_codec_control_VP8_COPY_REFERENCEPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_ref_frame_t>)>();

  vpx_codec_err_t vpx_codec_control_VP8_SET_POSTPROC(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vp8_postproc_cfg_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8_SET_POSTPROC(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8_SET_POSTPROCPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vp8_postproc_cfg_t>)>>(
      'vpx_codec_control_VP8_SET_POSTPROC');
  late final _vpx_codec_control_VP8_SET_POSTPROC =
      _vpx_codec_control_VP8_SET_POSTPROCPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vp8_postproc_cfg_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9_GET_REFERENCE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vp9_ref_frame_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9_GET_REFERENCE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9_GET_REFERENCEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vp9_ref_frame_t>)>>(
      'vpx_codec_control_VP9_GET_REFERENCE');
  late final _vpx_codec_control_VP9_GET_REFERENCE =
      _vpx_codec_control_VP9_GET_REFERENCEPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vp9_ref_frame_t>)>();

  /// !\brief Write VpxTplGopStats to file
  ///
  /// Accepts an opened file handle and writes \p tpl_gop_stats.
  ///
  /// \param[in]    tpl_file       A FILE pointer that's already been opened.
  /// \param[in]    tpl_gop_stats  VpxTplGopStats that contains TPL stats for the
  /// whole GOP.
  ///
  /// \return VPX_CODEC_OK if TPL stats are successfully written.
  vpx_codec_err_t vpx_write_tpl_gop_stats(
    ffi.Pointer<FILE> tpl_file,
    ffi.Pointer<VpxTplGopStats> tpl_gop_stats,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_write_tpl_gop_stats(
      tpl_file,
      tpl_gop_stats,
    ));
  }

  late final _vpx_write_tpl_gop_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<FILE>,
              ffi.Pointer<VpxTplGopStats>)>>('vpx_write_tpl_gop_stats');
  late final _vpx_write_tpl_gop_stats = _vpx_write_tpl_gop_statsPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<VpxTplGopStats>)>();

  /// !\brief Read VpxTplGopStats from file
  ///
  /// Accepts an opened file handle and reads TPL stats and stores them into
  /// \p tpl_gop_stats. Allocates memory for TPL stats.
  ///
  /// \param[in]     tpl_file       A FILE pointer that's already been opened.
  /// \param[out]    tpl_gop_stats  VpxTplGopStats that contains TPL stats for the
  /// whole GOP.
  ///
  /// \return VPX_CODEC_OK if TPL stats are successfully read from file.
  vpx_codec_err_t vpx_read_tpl_gop_stats(
    ffi.Pointer<FILE> tpl_file,
    ffi.Pointer<VpxTplGopStats> tpl_gop_stats,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_read_tpl_gop_stats(
      tpl_file,
      tpl_gop_stats,
    ));
  }

  late final _vpx_read_tpl_gop_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<FILE>,
              ffi.Pointer<VpxTplGopStats>)>>('vpx_read_tpl_gop_stats');
  late final _vpx_read_tpl_gop_stats = _vpx_read_tpl_gop_statsPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<VpxTplGopStats>)>();

  /// !\brief Free the memory allocated for VpxTplGopStats
  ///
  /// \param[in]    tpl_gop_stats  VpxTplGopStats that contains TPL stats for the
  /// whole GOP.
  void vpx_free_tpl_gop_stats(
    ffi.Pointer<VpxTplGopStats> tpl_gop_stats,
  ) {
    return _vpx_free_tpl_gop_stats(
      tpl_gop_stats,
    );
  }

  late final _vpx_free_tpl_gop_statsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VpxTplGopStats>)>>(
      'vpx_free_tpl_gop_stats');
  late final _vpx_free_tpl_gop_stats = _vpx_free_tpl_gop_statsPtr
      .asFunction<void Function(ffi.Pointer<VpxTplGopStats>)>();

  /// !\brief Initialize an encoder instance
  ///
  /// Initializes an encoder context using the given interface. Applications
  /// should call the vpx_codec_enc_init convenience macro instead of this
  /// function directly, to ensure that the ABI version number parameter
  /// is properly initialized.
  ///
  /// If the library was configured with --disable-multithread, this call
  /// is not thread safe and should be guarded with a lock if being used
  /// in a multithreaded context.
  ///
  /// If vpx_codec_enc_init_ver() fails, it is not necessary to call
  /// vpx_codec_destroy() on the encoder context.
  ///
  /// \param[in]    ctx     Pointer to this instance's context.
  /// \param[in]    iface   Pointer to the algorithm interface to use.
  /// \param[in]    cfg     Configuration to use, if known. May be NULL.
  /// \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
  /// \param[in]    ver     ABI version number. Must be set to
  /// VPX_ENCODER_ABI_VERSION
  /// \retval #VPX_CODEC_OK
  /// The decoder algorithm initialized.
  /// \retval #VPX_CODEC_MEM_ERROR
  /// Memory allocation failed.
  vpx_codec_err_t vpx_codec_enc_init_ver(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_iface_t> iface,
    ffi.Pointer<vpx_codec_enc_cfg_t> cfg,
    Dartvpx_codec_flags_t flags,
    int ver,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_enc_init_ver(
      ctx,
      iface,
      cfg,
      flags,
      ver,
    ));
  }

  late final _vpx_codec_enc_init_verPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>,
              vpx_codec_flags_t,
              ffi.Int)>>('vpx_codec_enc_init_ver');
  late final _vpx_codec_enc_init_ver = _vpx_codec_enc_init_verPtr.asFunction<
      int Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<vpx_codec_iface_t>,
          ffi.Pointer<vpx_codec_enc_cfg_t>, int, int)>();

  /// !\brief Initialize multi-encoder instance
  ///
  /// Initializes multi-encoder context using the given interface.
  /// Applications should call the vpx_codec_enc_init_multi convenience macro
  /// instead of this function directly, to ensure that the ABI version number
  /// parameter is properly initialized.
  ///
  /// \param[in]    ctx     Pointer to this instance's context.
  /// \param[in]    iface   Pointer to the algorithm interface to use.
  /// \param[in]    cfg     Configuration to use, if known. May be NULL.
  /// \param[in]    num_enc Total number of encoders.
  /// \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
  /// \param[in]    dsf     Pointer to down-sampling factors.
  /// \param[in]    ver     ABI version number. Must be set to
  /// VPX_ENCODER_ABI_VERSION
  /// \retval #VPX_CODEC_OK
  /// The encoder algorithm has been initialized.
  /// \retval #VPX_CODEC_MEM_ERROR
  /// Memory allocation failed.
  vpx_codec_err_t vpx_codec_enc_init_multi_ver(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_iface_t> iface,
    ffi.Pointer<vpx_codec_enc_cfg_t> cfg,
    int num_enc,
    Dartvpx_codec_flags_t flags,
    ffi.Pointer<vpx_rational_t> dsf,
    int ver,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_enc_init_multi_ver(
      ctx,
      iface,
      cfg,
      num_enc,
      flags,
      dsf,
      ver,
    ));
  }

  late final _vpx_codec_enc_init_multi_verPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>,
              ffi.Int,
              vpx_codec_flags_t,
              ffi.Pointer<vpx_rational_t>,
              ffi.Int)>>('vpx_codec_enc_init_multi_ver');
  late final _vpx_codec_enc_init_multi_ver =
      _vpx_codec_enc_init_multi_verPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>,
              int,
              int,
              ffi.Pointer<vpx_rational_t>,
              int)>();

  /// !\brief Get a default configuration
  ///
  /// Initializes a encoder configuration structure with default values. Supports
  /// the notion of "usages" so that an algorithm may offer different default
  /// settings depending on the user's intended goal. This function \ref SHOULD
  /// be called by all applications to initialize the configuration structure
  /// before specializing the configuration with application specific values.
  ///
  /// \param[in]    iface     Pointer to the algorithm interface to use.
  /// \param[out]   cfg       Configuration buffer to populate.
  /// \param[in]    usage     Must be set to 0.
  ///
  /// \retval #VPX_CODEC_OK
  /// The configuration was populated.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Interface is not an encoder interface.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// A parameter was NULL, or the usage value was not recognized.
  vpx_codec_err_t vpx_codec_enc_config_default(
    ffi.Pointer<vpx_codec_iface_t> iface,
    ffi.Pointer<vpx_codec_enc_cfg_t> cfg,
    int usage,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_enc_config_default(
      iface,
      cfg,
      usage,
    ));
  }

  late final _vpx_codec_enc_config_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>,
              ffi.UnsignedInt)>>('vpx_codec_enc_config_default');
  late final _vpx_codec_enc_config_default =
      _vpx_codec_enc_config_defaultPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>, int)>();

  /// !\brief Set or change configuration
  ///
  /// Reconfigures an encoder instance according to the given configuration.
  ///
  /// \param[in]    ctx     Pointer to this instance's context
  /// \param[in]    cfg     Configuration buffer to use
  ///
  /// \retval #VPX_CODEC_OK
  /// The configuration was populated.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Interface is not an encoder interface.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// A parameter was NULL, or the usage value was not recognized.
  vpx_codec_err_t vpx_codec_enc_config_set(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_enc_cfg_t> cfg,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_enc_config_set(
      ctx,
      cfg,
    ));
  }

  late final _vpx_codec_enc_config_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>)>>('vpx_codec_enc_config_set');
  late final _vpx_codec_enc_config_set =
      _vpx_codec_enc_config_setPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_enc_cfg_t>)>();

  /// !\brief Get global stream headers
  ///
  /// Retrieves a stream level global header packet, if supported by the codec.
  ///
  /// \li VP8: Unsupported
  /// \li VP9: Returns a buffer of <tt>ID (1 byte)|Length (1 byte)|Length
  /// bytes</tt> values. The function should be called after encoding to retrieve
  /// the most accurate information.
  ///
  /// \param[in]    ctx     Pointer to this instance's context
  ///
  /// \retval NULL
  /// Encoder does not support global header
  /// \retval Non-NULL
  /// Pointer to buffer containing global header packet. The buffer pointer
  /// and its contents are only valid for the lifetime of \a ctx. The contents
  /// may change in subsequent calls to the function.
  /// \sa
  /// https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate
  ffi.Pointer<vpx_fixed_buf_t> vpx_codec_get_global_headers(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
  ) {
    return _vpx_codec_get_global_headers(
      ctx,
    );
  }

  late final _vpx_codec_get_global_headersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_fixed_buf_t> Function(
              ffi.Pointer<vpx_codec_ctx_t>)>>('vpx_codec_get_global_headers');
  late final _vpx_codec_get_global_headers =
      _vpx_codec_get_global_headersPtr.asFunction<
          ffi.Pointer<vpx_fixed_buf_t> Function(
              ffi.Pointer<vpx_codec_ctx_t>)>();

  /// !\brief Encode a frame
  ///
  /// Encodes a video frame at the given "presentation time." The presentation
  /// time stamp (PTS) \ref MUST be strictly increasing.
  ///
  /// The encoder supports the notion of a soft real-time deadline. Given a
  /// non-zero value to the deadline parameter, the encoder will make a "best
  /// effort" guarantee to  return before the given time slice expires. It is
  /// implicit that limiting the available time to encode will degrade the
  /// output quality. The encoder can be given an unlimited time to produce the
  /// best possible frame by specifying a deadline of '0'. This deadline
  /// supersedes the VPx notion of "best quality, good quality, realtime".
  /// Applications that wish to map these former settings to the new deadline
  /// based system can use the symbols #VPX_DL_REALTIME, #VPX_DL_GOOD_QUALITY,
  /// and #VPX_DL_BEST_QUALITY.
  ///
  /// When the last frame has been passed to the encoder, this function should
  /// continue to be called, with the img parameter set to NULL. This will
  /// signal the end-of-stream condition to the encoder and allow it to encode
  /// any held buffers. Encoding is complete when vpx_codec_encode() is called
  /// and vpx_codec_get_cx_data() returns no data.
  ///
  /// \param[in]    ctx       Pointer to this instance's context
  /// \param[in]    img       Image data to encode, NULL to flush.
  /// \param[in]    pts       Presentation time stamp, in timebase units.
  /// \param[in]    duration  Duration to show frame, in timebase units.
  /// \param[in]    flags     Flags to use for encoding this frame.
  /// \param[in]    deadline  Time to spend encoding, in microseconds. (0=infinite)
  ///
  /// \retval #VPX_CODEC_OK
  /// The configuration was populated.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Interface is not an encoder interface.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// A parameter was NULL, the image format is unsupported, etc.
  vpx_codec_err_t vpx_codec_encode(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_image_t> img,
    Dartvpx_codec_pts_t pts,
    int duration,
    Dartvpx_enc_frame_flags_t flags,
    int deadline,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_encode(
      ctx,
      img,
      pts,
      duration,
      flags,
      deadline,
    ));
  }

  late final _vpx_codec_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_image_t>,
              vpx_codec_pts_t,
              ffi.UnsignedLong,
              vpx_enc_frame_flags_t,
              ffi.UnsignedLong)>>('vpx_codec_encode');
  late final _vpx_codec_encode = _vpx_codec_encodePtr.asFunction<
      int Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<vpx_image_t>, int,
          int, int, int)>();

  /// !\brief Set compressed data output buffer
  ///
  /// Sets the buffer that the codec should output the compressed data
  /// into. This call effectively sets the buffer pointer returned in the
  /// next VPX_CODEC_CX_FRAME_PKT packet. Subsequent packets will be
  /// appended into this buffer. The buffer is preserved across frames,
  /// so applications must periodically call this function after flushing
  /// the accumulated compressed data to disk or to the network to reset
  /// the pointer to the buffer's head.
  ///
  /// `pad_before` bytes will be skipped before writing the compressed
  /// data, and `pad_after` bytes will be appended to the packet. The size
  /// of the packet will be the sum of the size of the actual compressed
  /// data, pad_before, and pad_after. The padding bytes will be preserved
  /// (not overwritten).
  ///
  /// Note that calling this function does not guarantee that the returned
  /// compressed data will be placed into the specified buffer. In the
  /// event that the encoded data will not fit into the buffer provided,
  /// the returned packet \ref MAY point to an internal buffer, as it would
  /// if this call were never used. In this event, the output packet will
  /// NOT have any padding, and the application must free space and copy it
  /// to the proper place. This is of particular note in configurations
  /// that may output multiple packets for a single encoded frame (e.g., lagged
  /// encoding) or if the application does not reset the buffer periodically.
  ///
  /// Applications may restore the default behavior of the codec providing
  /// the compressed data buffer by calling this function with a NULL
  /// buffer.
  ///
  /// Applications \ref MUSTNOT call this function during iteration of
  /// vpx_codec_get_cx_data().
  ///
  /// \param[in]    ctx         Pointer to this instance's context
  /// \param[in]    buf         Buffer to store compressed data into
  /// \param[in]    pad_before  Bytes to skip before writing compressed data
  /// \param[in]    pad_after   Bytes to skip after writing compressed data
  ///
  /// \retval #VPX_CODEC_OK
  /// The buffer was set successfully.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// A parameter was NULL, the image format is unsupported, etc.
  vpx_codec_err_t vpx_codec_set_cx_data_buf(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_fixed_buf_t> buf,
    int pad_before,
    int pad_after,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_set_cx_data_buf(
      ctx,
      buf,
      pad_before,
      pad_after,
    ));
  }

  late final _vpx_codec_set_cx_data_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_fixed_buf_t>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('vpx_codec_set_cx_data_buf');
  late final _vpx_codec_set_cx_data_buf =
      _vpx_codec_set_cx_data_bufPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_fixed_buf_t>, int, int)>();

  /// !\brief Encoded data iterator
  ///
  /// Iterates over a list of data packets to be passed from the encoder to the
  /// application. The different kinds of packets available are enumerated in
  /// #vpx_codec_cx_pkt_kind.
  ///
  /// #VPX_CODEC_CX_FRAME_PKT packets should be passed to the application's
  /// muxer. Multiple compressed frames may be in the list.
  /// #VPX_CODEC_STATS_PKT packets should be appended to a global buffer.
  ///
  /// The application \ref MUST silently ignore any packet kinds that it does
  /// not recognize or support.
  ///
  /// The data buffers returned from this function are only guaranteed to be
  /// valid until the application makes another call to any vpx_codec_* function.
  ///
  /// \param[in]     ctx      Pointer to this instance's context
  /// \param[in,out] iter     Iterator storage, initialized to NULL
  ///
  /// \return Returns a pointer to an output data packet (compressed frame data,
  /// two-pass statistics, etc.) or NULL to signal end-of-list.
  ffi.Pointer<vpx_codec_cx_pkt_t> vpx_codec_get_cx_data(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_iter_t> iter,
  ) {
    return _vpx_codec_get_cx_data(
      ctx,
      iter,
    );
  }

  late final _vpx_codec_get_cx_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_codec_cx_pkt_t> Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iter_t>)>>('vpx_codec_get_cx_data');
  late final _vpx_codec_get_cx_data = _vpx_codec_get_cx_dataPtr.asFunction<
      ffi.Pointer<vpx_codec_cx_pkt_t> Function(
          ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<vpx_codec_iter_t>)>();

  /// !\brief Get Preview Frame
  ///
  /// Returns an image that can be used as a preview. Shows the image as it would
  /// exist at the decompressor. The application \ref MUST NOT write into this
  /// image buffer.
  ///
  /// \param[in]     ctx      Pointer to this instance's context
  ///
  /// \return Returns a pointer to a preview image, or NULL if no image is
  /// available.
  ffi.Pointer<vpx_image_t> vpx_codec_get_preview_frame(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
  ) {
    return _vpx_codec_get_preview_frame(
      ctx,
    );
  }

  late final _vpx_codec_get_preview_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_image_t> Function(
              ffi.Pointer<vpx_codec_ctx_t>)>>('vpx_codec_get_preview_frame');
  late final _vpx_codec_get_preview_frame =
      _vpx_codec_get_preview_framePtr.asFunction<
          ffi.Pointer<vpx_image_t> Function(ffi.Pointer<vpx_codec_ctx_t>)>();

  /// !\brief A single instance of the VP8 encoder.
  /// \deprecated This access mechanism is provided for backwards compatibility;
  /// prefer vpx_codec_vp8_cx().
  late final ffi.Pointer<vpx_codec_iface_t> _vpx_codec_vp8_cx_algo =
      _lookup<vpx_codec_iface_t>('vpx_codec_vp8_cx_algo');

  ffi.Pointer<vpx_codec_iface_t> get vpx_codec_vp8_cx_algo =>
      _vpx_codec_vp8_cx_algo;

  /// !\brief The interface to the VP8 encoder.
  ffi.Pointer<vpx_codec_iface_t> vpx_codec_vp8_cx() {
    return _vpx_codec_vp8_cx();
  }

  late final _vpx_codec_vp8_cxPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<vpx_codec_iface_t> Function()>>(
          'vpx_codec_vp8_cx');
  late final _vpx_codec_vp8_cx = _vpx_codec_vp8_cxPtr
      .asFunction<ffi.Pointer<vpx_codec_iface_t> Function()>();

  /// !\brief A single instance of the VP9 encoder.
  /// \deprecated This access mechanism is provided for backwards compatibility;
  /// prefer vpx_codec_vp9_cx().
  late final ffi.Pointer<vpx_codec_iface_t> _vpx_codec_vp9_cx_algo =
      _lookup<vpx_codec_iface_t>('vpx_codec_vp9_cx_algo');

  ffi.Pointer<vpx_codec_iface_t> get vpx_codec_vp9_cx_algo =>
      _vpx_codec_vp9_cx_algo;

  /// !\brief The interface to the VP9 encoder.
  ffi.Pointer<vpx_codec_iface_t> vpx_codec_vp9_cx() {
    return _vpx_codec_vp9_cx();
  }

  late final _vpx_codec_vp9_cxPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<vpx_codec_iface_t> Function()>>(
          'vpx_codec_vp9_cx');
  late final _vpx_codec_vp9_cx = _vpx_codec_vp9_cxPtr
      .asFunction<ffi.Pointer<vpx_codec_iface_t> Function()>();

  /// !\cond */
  /// /*!\brief VP8 encoder control function parameter type
  ///
  /// Defines the data types that VP8E control functions take. Note that
  /// additional common controls are defined in vp8.h
  vpx_codec_err_t vpx_codec_control_VP8E_SET_ROI_MAP(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_roi_map_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_ROI_MAP(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ROI_MAPPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_roi_map_t>)>>(
      'vpx_codec_control_VP8E_SET_ROI_MAP');
  late final _vpx_codec_control_VP8E_SET_ROI_MAP =
      _vpx_codec_control_VP8E_SET_ROI_MAPPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<vpx_roi_map_t>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_ACTIVEMAP(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_active_map_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_ACTIVEMAP(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ACTIVEMAPPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_active_map_t>)>>(
      'vpx_codec_control_VP8E_SET_ACTIVEMAP');
  late final _vpx_codec_control_VP8E_SET_ACTIVEMAP =
      _vpx_codec_control_VP8E_SET_ACTIVEMAPPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_active_map_t>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_SCALEMODE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_scaling_mode_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_SCALEMODE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_SCALEMODEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_scaling_mode_t>)>>(
      'vpx_codec_control_VP8E_SET_SCALEMODE');
  late final _vpx_codec_control_VP8E_SET_SCALEMODE =
      _vpx_codec_control_VP8E_SET_SCALEMODEPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_scaling_mode_t>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_CPUUSED(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_CPUUSED(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_CPUUSEDPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_CPUUSED');
  late final _vpx_codec_control_VP8E_SET_CPUUSED =
      _vpx_codec_control_VP8E_SET_CPUUSEDPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ENABLEAUTOALTREFPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF');
  late final _vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF =
      _vpx_codec_control_VP8E_SET_ENABLEAUTOALTREFPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_NOISE_SENSITIVITYPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY');
  late final _vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY =
      _vpx_codec_control_VP8E_SET_NOISE_SENSITIVITYPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_SHARPNESS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_SHARPNESS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_SHARPNESSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_SHARPNESS');
  late final _vpx_codec_control_VP8E_SET_SHARPNESS =
      _vpx_codec_control_VP8E_SET_SHARPNESSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_STATIC_THRESHOLDPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_STATIC_THRESHOLD');
  late final _vpx_codec_control_VP8E_SET_STATIC_THRESHOLD =
      _vpx_codec_control_VP8E_SET_STATIC_THRESHOLDPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_TOKEN_PARTITIONSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS');
  late final _vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS =
      _vpx_codec_control_VP8E_SET_TOKEN_PARTITIONSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_GET_LAST_QUANTIZER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_GET_LAST_QUANTIZERPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP8E_GET_LAST_QUANTIZER');
  late final _vpx_codec_control_VP8E_GET_LAST_QUANTIZER =
      _vpx_codec_control_VP8E_GET_LAST_QUANTIZERPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64Ptr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64');
  late final _vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64 =
      _vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64Ptr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ARNR_MAXFRAMESPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES');
  late final _vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES =
      _vpx_codec_control_VP8E_SET_ARNR_MAXFRAMESPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_STRENGTH(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_ARNR_STRENGTH(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ARNR_STRENGTHPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_ARNR_STRENGTH');
  late final _vpx_codec_control_VP8E_SET_ARNR_STRENGTH =
      _vpx_codec_control_VP8E_SET_ARNR_STRENGTHPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_TYPE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_ARNR_TYPE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_ARNR_TYPEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_ARNR_TYPE');
  late final _vpx_codec_control_VP8E_SET_ARNR_TYPE =
      _vpx_codec_control_VP8E_SET_ARNR_TYPEPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_TUNING(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_TUNING(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_TUNINGPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_TUNING');
  late final _vpx_codec_control_VP8E_SET_TUNING =
      _vpx_codec_control_VP8E_SET_TUNINGPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_CQ_LEVEL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_CQ_LEVEL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_CQ_LEVELPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_CQ_LEVEL');
  late final _vpx_codec_control_VP8E_SET_CQ_LEVEL =
      _vpx_codec_control_VP8E_SET_CQ_LEVELPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCTPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT');
  late final _vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT =
      _vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_FRAME_FLAGS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8E_SET_FRAME_FLAGS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_FRAME_FLAGSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_FRAME_FLAGS');
  late final _vpx_codec_control_VP8E_SET_FRAME_FLAGS =
      _vpx_codec_control_VP8E_SET_FRAME_FLAGSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCTPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT');
  late final _vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT =
      _vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT');
  late final _vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT =
      _vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_IDPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID');
  late final _vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID =
      _vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_IDPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE');
  late final _vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE =
      _vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODEPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_LOSSLESS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_LOSSLESS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_LOSSLESSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_LOSSLESS');
  late final _vpx_codec_control_VP9E_SET_LOSSLESS =
      _vpx_codec_control_VP9E_SET_LOSSLESSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_TILE_COLUMNS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_TILE_COLUMNS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_TILE_COLUMNSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_TILE_COLUMNS');
  late final _vpx_codec_control_VP9E_SET_TILE_COLUMNS =
      _vpx_codec_control_VP9E_SET_TILE_COLUMNSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_TILE_ROWS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_TILE_ROWS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_TILE_ROWSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_TILE_ROWS');
  late final _vpx_codec_control_VP9E_SET_TILE_ROWS =
      _vpx_codec_control_VP9E_SET_TILE_ROWSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODINGPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING');
  late final _vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING =
      _vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODINGPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_AQ_MODE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_AQ_MODE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_AQ_MODEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_AQ_MODE');
  late final _vpx_codec_control_VP9E_SET_AQ_MODE =
      _vpx_codec_control_VP9E_SET_AQ_MODEPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOSTPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST');
  late final _vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST =
      _vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOSTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_NOISE_SENSITIVITYPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY');
  late final _vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY =
      _vpx_codec_control_VP9E_SET_NOISE_SENSITIVITYPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_SVC(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVCPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_SVC');
  late final _vpx_codec_control_VP9E_SET_SVC =
      _vpx_codec_control_VP9E_SET_SVCPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_ROI_MAP(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_roi_map_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_ROI_MAP(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_ROI_MAPPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_roi_map_t>)>>(
      'vpx_codec_control_VP9E_SET_ROI_MAP');
  late final _vpx_codec_control_VP9E_SET_ROI_MAP =
      _vpx_codec_control_VP9E_SET_ROI_MAPPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<vpx_roi_map_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_PARAMETERS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_SVC_PARAMETERS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_PARAMETERSPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Void>)>>(
      'vpx_codec_control_VP9E_SET_SVC_PARAMETERS');
  late final _vpx_codec_control_VP9E_SET_SVC_PARAMETERS =
      _vpx_codec_control_VP9E_SET_SVC_PARAMETERSPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Void>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_LAYER_ID(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_layer_id_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_SVC_LAYER_ID(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_LAYER_IDPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_layer_id_t>)>>(
      'vpx_codec_control_VP9E_SET_SVC_LAYER_ID');
  late final _vpx_codec_control_VP9E_SET_SVC_LAYER_ID =
      _vpx_codec_control_VP9E_SET_SVC_LAYER_IDPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_layer_id_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_TUNE_CONTENT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_TUNE_CONTENT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_TUNE_CONTENTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_TUNE_CONTENT');
  late final _vpx_codec_control_VP9E_SET_TUNE_CONTENT =
      _vpx_codec_control_VP9E_SET_TUNE_CONTENTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_SVC_LAYER_ID(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_layer_id_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_GET_SVC_LAYER_ID(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_SVC_LAYER_IDPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_layer_id_t>)>>(
      'vpx_codec_control_VP9E_GET_SVC_LAYER_ID');
  late final _vpx_codec_control_VP9E_GET_SVC_LAYER_ID =
      _vpx_codec_control_VP9E_GET_SVC_LAYER_IDPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_layer_id_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_REGISTER_CX_CALLBACK(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_REGISTER_CX_CALLBACK(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_REGISTER_CX_CALLBACKPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Void>)>>(
      'vpx_codec_control_VP9E_REGISTER_CX_CALLBACK');
  late final _vpx_codec_control_VP9E_REGISTER_CX_CALLBACK =
      _vpx_codec_control_VP9E_REGISTER_CX_CALLBACKPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Void>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_COLOR_SPACE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_COLOR_SPACE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_COLOR_SPACEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_COLOR_SPACE');
  late final _vpx_codec_control_VP9E_SET_COLOR_SPACE =
      _vpx_codec_control_VP9E_SET_COLOR_SPACEPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_MIN_GF_INTERVALPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL');
  late final _vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL =
      _vpx_codec_control_VP9E_SET_MIN_GF_INTERVALPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_MAX_GF_INTERVALPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL');
  late final _vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL =
      _vpx_codec_control_VP9E_SET_MAX_GF_INTERVALPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_ACTIVEMAP(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_active_map_t> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_GET_ACTIVEMAP(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_ACTIVEMAPPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_active_map_t>)>>(
      'vpx_codec_control_VP9E_GET_ACTIVEMAP');
  late final _vpx_codec_control_VP9E_GET_ACTIVEMAP =
      _vpx_codec_control_VP9E_GET_ACTIVEMAPPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_active_map_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_COLOR_RANGE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_COLOR_RANGE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_COLOR_RANGEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_COLOR_RANGE');
  late final _vpx_codec_control_VP9E_SET_COLOR_RANGE =
      _vpx_codec_control_VP9E_SET_COLOR_RANGEPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_ref_frame_config_t> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIGPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_ref_frame_config_t>)>>(
      'vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG');
  late final _vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG =
      _vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIGPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_ref_frame_config_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_RENDER_SIZE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_RENDER_SIZE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_RENDER_SIZEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('vpx_codec_control_VP9E_SET_RENDER_SIZE');
  late final _vpx_codec_control_VP9E_SET_RENDER_SIZE =
      _vpx_codec_control_VP9E_SET_RENDER_SIZEPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_TARGET_LEVEL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_TARGET_LEVEL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_TARGET_LEVELPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_TARGET_LEVEL');
  late final _vpx_codec_control_VP9E_SET_TARGET_LEVEL =
      _vpx_codec_control_VP9E_SET_TARGET_LEVELPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_ROW_MT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_ROW_MT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_ROW_MTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_ROW_MT');
  late final _vpx_codec_control_VP9E_SET_ROW_MT =
      _vpx_codec_control_VP9E_SET_ROW_MTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_LEVEL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_GET_LEVEL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_LEVELPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('vpx_codec_control_VP9E_GET_LEVEL');
  late final _vpx_codec_control_VP9E_GET_LEVEL =
      _vpx_codec_control_VP9E_GET_LEVELPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_ALT_REF_AQ(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_ALT_REF_AQ(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_ALT_REF_AQPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_ALT_REF_AQ');
  late final _vpx_codec_control_VP9E_SET_ALT_REF_AQ =
      _vpx_codec_control_VP9E_SET_ALT_REF_AQPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT');
  late final _vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT =
      _vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TESTPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.UnsignedInt Function(
                      ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
          'vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST');
  late final _vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST =
      _vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TESTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PREDPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED');
  late final _vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED =
      _vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PREDPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_frame_drop_t> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYERPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_frame_drop_t>)>>(
      'vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER');
  late final _vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER =
      _vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYERPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_frame_drop_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_ref_frame_config_t> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIGPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_ref_frame_config_t>)>>(
      'vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG');
  late final _vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG =
      _vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIGPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_ref_frame_config_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REFPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.UnsignedInt)>>(
      'vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF');
  late final _vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF =
      _vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REFPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_svc_spatial_layer_sync_t> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNCPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_svc_spatial_layer_sync_t>)>>(
      'vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC');
  late final _vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC =
      _vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNCPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_svc_spatial_layer_sync_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_TPL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_TPL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_TPLPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_TPL');
  late final _vpx_codec_control_VP9E_SET_TPL =
      _vpx_codec_control_VP9E_SET_TPLPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_POSTENCODE_DROP(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_POSTENCODE_DROP(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_POSTENCODE_DROPPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.UnsignedInt)>>('vpx_codec_control_VP9E_SET_POSTENCODE_DROP');
  late final _vpx_codec_control_VP9E_SET_POSTENCODE_DROP =
      _vpx_codec_control_VP9E_SET_POSTENCODE_DROPPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_DELTA_Q_UV(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9E_SET_DELTA_Q_UV(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_DELTA_Q_UVPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_DELTA_Q_UV');
  late final _vpx_codec_control_VP9E_SET_DELTA_Q_UV =
      _vpx_codec_control_VP9E_SET_DELTA_Q_UVPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBRPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.UnsignedInt Function(
                      ffi.Pointer<vpx_codec_ctx_t>, ffi.Int, ffi.Int)>>(
          'vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR');
  late final _vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR =
      _vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBRPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTERPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTER');
  late final _vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTER =
      _vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTERPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_rc_funcs_t> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROLPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_rc_funcs_t>)>>(
      'vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROL');
  late final _vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROL =
      _vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROLPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_rc_funcs_t>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRLPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRL');
  late final _vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRL =
      _vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRLPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_LOOPFILTER_LEVEL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_GET_LOOPFILTER_LEVEL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_LOOPFILTER_LEVELPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP9E_GET_LOOPFILTER_LEVEL');
  late final _vpx_codec_control_VP9E_GET_LOOPFILTER_LEVEL =
      _vpx_codec_control_VP9E_GET_LOOPFILTER_LEVELPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERSPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERS');
  late final _vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERS =
      _vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERSPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRL(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRL(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRLPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRL');
  late final _vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRL =
      _vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRLPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASS(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASS(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASSPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASS');
  late final _vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASS =
      _vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASSPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  /// !\brief A single instance of the VP8 decoder.
  /// \deprecated This access mechanism is provided for backwards compatibility;
  /// prefer vpx_codec_vp8_dx().
  late final ffi.Pointer<vpx_codec_iface_t> _vpx_codec_vp8_dx_algo =
      _lookup<vpx_codec_iface_t>('vpx_codec_vp8_dx_algo');

  ffi.Pointer<vpx_codec_iface_t> get vpx_codec_vp8_dx_algo =>
      _vpx_codec_vp8_dx_algo;

  /// !\brief The interface to the VP8 decoder.
  ffi.Pointer<vpx_codec_iface_t> vpx_codec_vp8_dx() {
    return _vpx_codec_vp8_dx();
  }

  late final _vpx_codec_vp8_dxPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<vpx_codec_iface_t> Function()>>(
          'vpx_codec_vp8_dx');
  late final _vpx_codec_vp8_dx = _vpx_codec_vp8_dxPtr
      .asFunction<ffi.Pointer<vpx_codec_iface_t> Function()>();

  /// !\brief A single instance of the VP9 decoder.
  /// \deprecated This access mechanism is provided for backwards compatibility;
  /// prefer vpx_codec_vp9_dx().
  late final ffi.Pointer<vpx_codec_iface_t> _vpx_codec_vp9_dx_algo =
      _lookup<vpx_codec_iface_t>('vpx_codec_vp9_dx_algo');

  ffi.Pointer<vpx_codec_iface_t> get vpx_codec_vp9_dx_algo =>
      _vpx_codec_vp9_dx_algo;

  /// !\brief The interface to the VP9 decoder.
  ffi.Pointer<vpx_codec_iface_t> vpx_codec_vp9_dx() {
    return _vpx_codec_vp9_dx();
  }

  late final _vpx_codec_vp9_dxPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<vpx_codec_iface_t> Function()>>(
          'vpx_codec_vp9_dx');
  late final _vpx_codec_vp9_dx = _vpx_codec_vp9_dxPtr
      .asFunction<ffi.Pointer<vpx_codec_iface_t> Function()>();

  /// !\cond */
  /// /*!\brief VP8 decoder control function parameter type
  ///
  /// Defines the data types that VP8D control functions take. Note that
  /// additional common controls are defined in vp8.h
  vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8D_GET_LAST_REF_UPDATESPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP8D_GET_LAST_REF_UPDATES');
  late final _vpx_codec_control_VP8D_GET_LAST_REF_UPDATES =
      _vpx_codec_control_VP8D_GET_LAST_REF_UPDATESPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8D_GET_FRAME_CORRUPTEDPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP8D_GET_FRAME_CORRUPTED');
  late final _vpx_codec_control_VP8D_GET_FRAME_CORRUPTED =
      _vpx_codec_control_VP8D_GET_FRAME_CORRUPTEDPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_USED(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8D_GET_LAST_REF_USED(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8D_GET_LAST_REF_USEDPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP8D_GET_LAST_REF_USED');
  late final _vpx_codec_control_VP8D_GET_LAST_REF_USED =
      _vpx_codec_control_VP8D_GET_LAST_REF_USEDPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VPXD_SET_DECRYPTOR(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_decrypt_init> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VPXD_SET_DECRYPTOR(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VPXD_SET_DECRYPTORPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_decrypt_init>)>>(
      'vpx_codec_control_VPXD_SET_DECRYPTOR');
  late final _vpx_codec_control_VPXD_SET_DECRYPTOR =
      _vpx_codec_control_VPXD_SET_DECRYPTORPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_decrypt_init>)>();

  vpx_codec_err_t vpx_codec_control_VP8D_SET_DECRYPTOR(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<vpx_decrypt_init> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP8D_SET_DECRYPTOR(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP8D_SET_DECRYPTORPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<vpx_decrypt_init>)>>(
      'vpx_codec_control_VP8D_SET_DECRYPTOR');
  late final _vpx_codec_control_VP8D_SET_DECRYPTOR =
      _vpx_codec_control_VP8D_SET_DECRYPTORPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<vpx_decrypt_init>)>();

  vpx_codec_err_t vpx_codec_control_VP9D_GET_FRAME_SIZE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9D_GET_FRAME_SIZE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9D_GET_FRAME_SIZEPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('vpx_codec_control_VP9D_GET_FRAME_SIZE');
  late final _vpx_codec_control_VP9D_GET_FRAME_SIZE =
      _vpx_codec_control_VP9D_GET_FRAME_SIZEPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9D_GET_DISPLAY_SIZE(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9D_GET_DISPLAY_SIZE(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9D_GET_DISPLAY_SIZEPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VP9D_GET_DISPLAY_SIZE');
  late final _vpx_codec_control_VP9D_GET_DISPLAY_SIZE =
      _vpx_codec_control_VP9D_GET_DISPLAY_SIZEPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9D_GET_BIT_DEPTH(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.UnsignedInt> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9D_GET_BIT_DEPTH(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9D_GET_BIT_DEPTHPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.UnsignedInt>)>>(
      'vpx_codec_control_VP9D_GET_BIT_DEPTH');
  late final _vpx_codec_control_VP9D_GET_BIT_DEPTH =
      _vpx_codec_control_VP9D_GET_BIT_DEPTHPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>, int,
              ffi.Pointer<ffi.UnsignedInt>)>();

  vpx_codec_err_t vpx_codec_control_VP9_SET_BYTE_ALIGNMENT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9_SET_BYTE_ALIGNMENT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9_SET_BYTE_ALIGNMENTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9_SET_BYTE_ALIGNMENT');
  late final _vpx_codec_control_VP9_SET_BYTE_ALIGNMENT =
      _vpx_codec_control_VP9_SET_BYTE_ALIGNMENTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER');
  late final _vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER =
      _vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDERPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9_SET_SKIP_LOOP_FILTERPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER');
  late final _vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER =
      _vpx_codec_control_VP9_SET_SKIP_LOOP_FILTERPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYERPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER');
  late final _vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER =
      _vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYERPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VPXD_GET_LAST_QUANTIZER(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VPXD_GET_LAST_QUANTIZER(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VPXD_GET_LAST_QUANTIZERPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
                  ffi.Pointer<ffi.Int>)>>(
      'vpx_codec_control_VPXD_GET_LAST_QUANTIZER');
  late final _vpx_codec_control_VPXD_GET_LAST_QUANTIZER =
      _vpx_codec_control_VPXD_GET_LAST_QUANTIZERPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>, int, ffi.Pointer<ffi.Int>)>();

  vpx_codec_err_t vpx_codec_control_VP9D_SET_ROW_MT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_control_VP9D_SET_ROW_MT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9D_SET_ROW_MTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9D_SET_ROW_MT');
  late final _vpx_codec_control_VP9D_SET_ROW_MT =
      _vpx_codec_control_VP9D_SET_ROW_MTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  vpx_codec_err_t vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT(
    ffi.Pointer<vpx_codec_ctx_t> arg0,
    int arg1,
    int arg2,
  ) {
    return vpx_codec_err_t
        .fromValue(_vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT(
      arg0,
      arg1,
      arg2,
    ));
  }

  late final _vpx_codec_control_VP9D_SET_LOOP_FILTER_OPTPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Int,
              ffi.Int)>>('vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT');
  late final _vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT =
      _vpx_codec_control_VP9D_SET_LOOP_FILTER_OPTPtr
          .asFunction<int Function(ffi.Pointer<vpx_codec_ctx_t>, int, int)>();

  /// !\brief Initialize a decoder instance
  ///
  /// Initializes a decoder context using the given interface. Applications
  /// should call the vpx_codec_dec_init convenience macro instead of this
  /// function directly, to ensure that the ABI version number parameter
  /// is properly initialized.
  ///
  /// If the library was configured with --disable-multithread, this call
  /// is not thread safe and should be guarded with a lock if being used
  /// in a multithreaded context.
  ///
  /// \param[in]    ctx     Pointer to this instance's context.
  /// \param[in]    iface   Pointer to the algorithm interface to use.
  /// \param[in]    cfg     Configuration to use, if known. May be NULL.
  /// \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
  /// \param[in]    ver     ABI version number. Must be set to
  /// VPX_DECODER_ABI_VERSION
  /// \retval #VPX_CODEC_OK
  /// The decoder algorithm has been initialized.
  /// \retval #VPX_CODEC_MEM_ERROR
  /// Memory allocation failed.
  vpx_codec_err_t vpx_codec_dec_init_ver(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_iface_t> iface,
    ffi.Pointer<vpx_codec_dec_cfg_t> cfg,
    Dartvpx_codec_flags_t flags,
    int ver,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_dec_init_ver(
      ctx,
      iface,
      cfg,
      flags,
      ver,
    ));
  }

  late final _vpx_codec_dec_init_verPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iface_t>,
              ffi.Pointer<vpx_codec_dec_cfg_t>,
              vpx_codec_flags_t,
              ffi.Int)>>('vpx_codec_dec_init_ver');
  late final _vpx_codec_dec_init_ver = _vpx_codec_dec_init_verPtr.asFunction<
      int Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<vpx_codec_iface_t>,
          ffi.Pointer<vpx_codec_dec_cfg_t>, int, int)>();

  /// !\brief Parse stream info from a buffer
  ///
  /// Performs high level parsing of the bitstream. Construction of a decoder
  /// context is not necessary. Can be used to determine if the bitstream is
  /// of the proper format, and to extract information from the stream.
  ///
  /// \param[in]      iface   Pointer to the algorithm interface
  /// \param[in]      data    Pointer to a block of data to parse
  /// \param[in]      data_sz Size of the data buffer
  /// \param[in,out]  si      Pointer to stream info to update. The size member
  /// \ref MUST be properly initialized, but \ref MAY be
  /// clobbered by the algorithm. This parameter \ref MAY
  /// be NULL.
  ///
  /// \retval #VPX_CODEC_OK
  /// Bitstream is parsable and stream information updated
  vpx_codec_err_t vpx_codec_peek_stream_info(
    ffi.Pointer<vpx_codec_iface_t> iface,
    ffi.Pointer<ffi.Uint8> data,
    int data_sz,
    ffi.Pointer<vpx_codec_stream_info_t> si,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_peek_stream_info(
      iface,
      data,
      data_sz,
      si,
    ));
  }

  late final _vpx_codec_peek_stream_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<vpx_codec_iface_t>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.UnsignedInt,
                  ffi.Pointer<vpx_codec_stream_info_t>)>>(
      'vpx_codec_peek_stream_info');
  late final _vpx_codec_peek_stream_info =
      _vpx_codec_peek_stream_infoPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_iface_t>, ffi.Pointer<ffi.Uint8>,
              int, ffi.Pointer<vpx_codec_stream_info_t>)>();

  /// !\brief Return information about the current stream.
  ///
  /// Returns information about the stream that has been parsed during decoding.
  ///
  /// \param[in]      ctx     Pointer to this instance's context
  /// \param[in,out]  si      Pointer to stream info to update. The size member
  /// \ref MUST be properly initialized, but \ref MAY be
  /// clobbered by the algorithm. This parameter \ref MAY
  /// be NULL.
  ///
  /// \retval #VPX_CODEC_OK
  /// Bitstream is parsable and stream information updated
  vpx_codec_err_t vpx_codec_get_stream_info(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_stream_info_t> si,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_get_stream_info(
      ctx,
      si,
    ));
  }

  late final _vpx_codec_get_stream_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<vpx_codec_ctx_t>,
                  ffi.Pointer<vpx_codec_stream_info_t>)>>(
      'vpx_codec_get_stream_info');
  late final _vpx_codec_get_stream_info =
      _vpx_codec_get_stream_infoPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_stream_info_t>)>();

  /// !\brief Decode data
  ///
  /// Processes a buffer of coded data. If the processing results in a new
  /// decoded frame becoming available, put_slice and put_frame callbacks may be
  /// invoked, as appropriate. Encoded data \ref MUST be passed in DTS (decode
  /// time stamp) order. Frames produced will always be in PTS (presentation
  /// time stamp) order.
  /// If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,
  /// data and data_sz can contain a fragment of the encoded frame. Fragment
  /// \#n must contain at least partition \#n, but can also contain subsequent
  /// partitions (\#n+1 - \#n+i), and if so, fragments \#n+1, .., \#n+i must
  /// be empty. When no more data is available, this function should be called
  /// with NULL as data and 0 as data_sz. The memory passed to this function
  /// must be available until the frame has been decoded.
  ///
  /// \param[in] ctx          Pointer to this instance's context
  /// \param[in] data         Pointer to this block of new coded data. If
  /// NULL, the put_frame callback is invoked for
  /// the previously decoded frame.
  /// \param[in] data_sz      Size of the coded data, in bytes.
  /// \param[in] user_priv    Application specific data to associate with
  /// this frame.
  /// \param[in] deadline     Soft deadline the decoder should attempt to meet,
  /// in us. Set to zero for unlimited.
  ///
  /// \return Returns #VPX_CODEC_OK if the coded data was processed completely
  /// and future pictures can be decoded without error. Otherwise,
  /// see the descriptions of the other error codes in ::vpx_codec_err_t
  /// for recoverability capabilities.
  vpx_codec_err_t vpx_codec_decode(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int data_sz,
    ffi.Pointer<ffi.Void> user_priv,
    int deadline,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_decode(
      ctx,
      data,
      data_sz,
      user_priv,
      deadline,
    ));
  }

  late final _vpx_codec_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.Long)>>('vpx_codec_decode');
  late final _vpx_codec_decode = _vpx_codec_decodePtr.asFunction<
      int Function(ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Void>, int)>();

  /// !\brief Decoded frames iterator
  ///
  /// Iterates over a list of the frames available for display. The iterator
  /// storage should be initialized to NULL to start the iteration. Iteration is
  /// complete when this function returns NULL.
  ///
  /// The list of available frames becomes valid upon completion of the
  /// vpx_codec_decode call, and remains valid until the next call to
  /// vpx_codec_decode.
  ///
  /// \param[in]     ctx      Pointer to this instance's context
  /// \param[in,out] iter     Iterator storage, initialized to NULL
  ///
  /// \return Returns a pointer to an image, if one is ready for display. Frames
  /// produced will always be in PTS (presentation time stamp) order.
  ffi.Pointer<vpx_image_t> vpx_codec_get_frame(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    ffi.Pointer<vpx_codec_iter_t> iter,
  ) {
    return _vpx_codec_get_frame(
      ctx,
      iter,
    );
  }

  late final _vpx_codec_get_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<vpx_image_t> Function(ffi.Pointer<vpx_codec_ctx_t>,
              ffi.Pointer<vpx_codec_iter_t>)>>('vpx_codec_get_frame');
  late final _vpx_codec_get_frame = _vpx_codec_get_framePtr.asFunction<
      ffi.Pointer<vpx_image_t> Function(
          ffi.Pointer<vpx_codec_ctx_t>, ffi.Pointer<vpx_codec_iter_t>)>();

  /// !\brief Register for notification of frame completion.
  ///
  /// Registers a given function to be called when a decoded frame is
  /// available.
  ///
  /// \param[in] ctx          Pointer to this instance's context
  /// \param[in] cb           Pointer to the callback function
  /// \param[in] user_priv    User's private data
  ///
  /// \retval #VPX_CODEC_OK
  /// Callback successfully registered.
  /// \retval #VPX_CODEC_ERROR
  /// Decoder context not initialized.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Algorithm not capable of posting frame completion.
  vpx_codec_err_t vpx_codec_register_put_frame_cb(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    vpx_codec_put_frame_cb_fn_t cb,
    ffi.Pointer<ffi.Void> user_priv,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_register_put_frame_cb(
      ctx,
      cb,
      user_priv,
    ));
  }

  late final _vpx_codec_register_put_frame_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              vpx_codec_put_frame_cb_fn_t,
              ffi.Pointer<ffi.Void>)>>('vpx_codec_register_put_frame_cb');
  late final _vpx_codec_register_put_frame_cb =
      _vpx_codec_register_put_frame_cbPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>,
              vpx_codec_put_frame_cb_fn_t, ffi.Pointer<ffi.Void>)>();

  /// !\brief Register for notification of slice completion.
  ///
  /// Registers a given function to be called when a decoded slice is
  /// available.
  ///
  /// \param[in] ctx          Pointer to this instance's context
  /// \param[in] cb           Pointer to the callback function
  /// \param[in] user_priv    User's private data
  ///
  /// \retval #VPX_CODEC_OK
  /// Callback successfully registered.
  /// \retval #VPX_CODEC_ERROR
  /// Decoder context not initialized.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Algorithm not capable of posting slice completion.
  vpx_codec_err_t vpx_codec_register_put_slice_cb(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    vpx_codec_put_slice_cb_fn_t cb,
    ffi.Pointer<ffi.Void> user_priv,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_register_put_slice_cb(
      ctx,
      cb,
      user_priv,
    ));
  }

  late final _vpx_codec_register_put_slice_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              vpx_codec_put_slice_cb_fn_t,
              ffi.Pointer<ffi.Void>)>>('vpx_codec_register_put_slice_cb');
  late final _vpx_codec_register_put_slice_cb =
      _vpx_codec_register_put_slice_cbPtr.asFunction<
          int Function(ffi.Pointer<vpx_codec_ctx_t>,
              vpx_codec_put_slice_cb_fn_t, ffi.Pointer<ffi.Void>)>();

  /// !\brief Pass in external frame buffers for the decoder to use.
  ///
  /// Registers functions to be called when libvpx needs a frame buffer
  /// to decode the current frame and a function to be called when libvpx does
  /// not internally reference the frame buffer. This set function must
  /// be called before the first call to decode or libvpx will assume the
  /// default behavior of allocating frame buffers internally.
  ///
  /// \param[in] ctx          Pointer to this instance's context
  /// \param[in] cb_get       Pointer to the get callback function
  /// \param[in] cb_release   Pointer to the release callback function
  /// \param[in] cb_priv      Callback's private data
  ///
  /// \retval #VPX_CODEC_OK
  /// External frame buffers will be used by libvpx.
  /// \retval #VPX_CODEC_INVALID_PARAM
  /// One or more of the callbacks were NULL.
  /// \retval #VPX_CODEC_ERROR
  /// Decoder context not initialized.
  /// \retval #VPX_CODEC_INCAPABLE
  /// Algorithm not capable of using external frame buffers.
  ///
  /// \note
  /// When decoding VP9, the application may be required to pass in at least
  /// #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS external frame
  /// buffers.
  vpx_codec_err_t vpx_codec_set_frame_buffer_functions(
    ffi.Pointer<vpx_codec_ctx_t> ctx,
    vpx_get_frame_buffer_cb_fn_t cb_get,
    vpx_release_frame_buffer_cb_fn_t cb_release,
    ffi.Pointer<ffi.Void> cb_priv,
  ) {
    return vpx_codec_err_t.fromValue(_vpx_codec_set_frame_buffer_functions(
      ctx,
      cb_get,
      cb_release,
      cb_priv,
    ));
  }

  late final _vpx_codec_set_frame_buffer_functionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              vpx_get_frame_buffer_cb_fn_t,
              vpx_release_frame_buffer_cb_fn_t,
              ffi.Pointer<ffi.Void>)>>('vpx_codec_set_frame_buffer_functions');
  late final _vpx_codec_set_frame_buffer_functions =
      _vpx_codec_set_frame_buffer_functionsPtr.asFunction<
          int Function(
              ffi.Pointer<vpx_codec_ctx_t>,
              vpx_get_frame_buffer_cb_fn_t,
              vpx_release_frame_buffer_cb_fn_t,
              ffi.Pointer<ffi.Void>)>();
}

/// !\brief List of supported image formats
enum vpx_img_fmt {
  VPX_IMG_FMT_NONE(0),
  VPX_IMG_FMT_YV12(769),
  VPX_IMG_FMT_I420(258),
  VPX_IMG_FMT_I422(261),
  VPX_IMG_FMT_I444(262),
  VPX_IMG_FMT_I440(263),
  VPX_IMG_FMT_NV12(265),
  VPX_IMG_FMT_I42016(2306),
  VPX_IMG_FMT_I42216(2309),
  VPX_IMG_FMT_I44416(2310),
  VPX_IMG_FMT_I44016(2311);

  final int value;
  const vpx_img_fmt(this.value);

  static vpx_img_fmt fromValue(int value) => switch (value) {
        0 => VPX_IMG_FMT_NONE,
        769 => VPX_IMG_FMT_YV12,
        258 => VPX_IMG_FMT_I420,
        261 => VPX_IMG_FMT_I422,
        262 => VPX_IMG_FMT_I444,
        263 => VPX_IMG_FMT_I440,
        265 => VPX_IMG_FMT_NV12,
        2306 => VPX_IMG_FMT_I42016,
        2309 => VPX_IMG_FMT_I42216,
        2310 => VPX_IMG_FMT_I44416,
        2311 => VPX_IMG_FMT_I44016,
        _ => throw ArgumentError('Unknown value for vpx_img_fmt: $value'),
      };
}

/// !\brief List of supported color spaces
enum vpx_color_space {
  /// < Unknown
  VPX_CS_UNKNOWN(0),

  /// < BT.601
  VPX_CS_BT_601(1),

  /// < BT.709
  VPX_CS_BT_709(2),

  /// < SMPTE.170
  VPX_CS_SMPTE_170(3),

  /// < SMPTE.240
  VPX_CS_SMPTE_240(4),

  /// < BT.2020
  VPX_CS_BT_2020(5),

  /// < Reserved
  VPX_CS_RESERVED(6),

  /// < sRGB
  VPX_CS_SRGB(7);

  final int value;
  const vpx_color_space(this.value);

  static vpx_color_space fromValue(int value) => switch (value) {
        0 => VPX_CS_UNKNOWN,
        1 => VPX_CS_BT_601,
        2 => VPX_CS_BT_709,
        3 => VPX_CS_SMPTE_170,
        4 => VPX_CS_SMPTE_240,
        5 => VPX_CS_BT_2020,
        6 => VPX_CS_RESERVED,
        7 => VPX_CS_SRGB,
        _ => throw ArgumentError('Unknown value for vpx_color_space: $value'),
      };
}

/// !\brief List of supported color range
enum vpx_color_range {
  /// < Y [16..235], UV [16..240]
  VPX_CR_STUDIO_RANGE(0),

  /// < YUV/RGB [0..255]
  VPX_CR_FULL_RANGE(1);

  final int value;
  const vpx_color_range(this.value);

  static vpx_color_range fromValue(int value) => switch (value) {
        0 => VPX_CR_STUDIO_RANGE,
        1 => VPX_CR_FULL_RANGE,
        _ => throw ArgumentError('Unknown value for vpx_color_range: $value'),
      };
}

/// \brief Image Descriptor
final class vpx_image extends ffi.Struct {
  /// < Image Format
  @ffi.UnsignedInt()
  external int fmtAsInt;

  vpx_img_fmt get fmt => vpx_img_fmt.fromValue(fmtAsInt);

  /// < Color Space
  @ffi.UnsignedInt()
  external int csAsInt;

  vpx_color_space get cs => vpx_color_space.fromValue(csAsInt);

  /// < Color Range
  @ffi.UnsignedInt()
  external int rangeAsInt;

  vpx_color_range get range => vpx_color_range.fromValue(rangeAsInt);

  /// < Stored image width
  @ffi.UnsignedInt()
  external int w;

  /// < Stored image height
  @ffi.UnsignedInt()
  external int h;

  /// < Stored image bit-depth
  @ffi.UnsignedInt()
  external int bit_depth;

  /// < Displayed image width
  @ffi.UnsignedInt()
  external int d_w;

  /// < Displayed image height
  @ffi.UnsignedInt()
  external int d_h;

  /// < Intended rendering image width
  @ffi.UnsignedInt()
  external int r_w;

  /// < Intended rendering image height
  @ffi.UnsignedInt()
  external int r_h;

  /// < subsampling order, X
  @ffi.UnsignedInt()
  external int x_chroma_shift;

  /// < subsampling order, Y
  @ffi.UnsignedInt()
  external int y_chroma_shift;

  /// < pointer to the top left pixel for each plane
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<ffi.UnsignedChar>> planes;

  /// < stride between rows for each plane
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> stride;

  /// < bits per sample (for packed formats)
  @ffi.Int()
  external int bps;

  /// !\brief The following member may be set by the application to associate
  /// data with this image.
  external ffi.Pointer<ffi.Void> user_priv;

  /// < private
  external ffi.Pointer<ffi.UnsignedChar> img_data;

  /// < private
  @ffi.Int()
  external int img_data_owner;

  /// < private
  @ffi.Int()
  external int self_allocd;

  /// < Frame buffer data associated with the image.
  external ffi.Pointer<ffi.Void> fb_priv;
}

/// \brief Image Descriptor
typedef vpx_image_t = vpx_image;

/// \brief Representation of a rectangle on a surface
final class vpx_image_rect extends ffi.Struct {
  /// < leftmost column
  @ffi.UnsignedInt()
  external int x;

  /// < topmost row
  @ffi.UnsignedInt()
  external int y;

  /// < width
  @ffi.UnsignedInt()
  external int w;

  /// < height
  @ffi.UnsignedInt()
  external int h;
}

/// \brief Representation of a rectangle on a surface
typedef vpx_image_rect_t = vpx_image_rect;

/// !\brief Algorithm return codes
enum vpx_codec_err_t {
  /// !\brief Operation completed without error
  VPX_CODEC_OK(0),

  /// !\brief Unspecified error
  VPX_CODEC_ERROR(1),

  /// !\brief Memory operation failed
  VPX_CODEC_MEM_ERROR(2),

  /// !\brief ABI version mismatch
  VPX_CODEC_ABI_MISMATCH(3),

  /// !\brief Algorithm does not have required capability
  VPX_CODEC_INCAPABLE(4),

  /// !\brief The given bitstream is not supported.
  ///
  /// The bitstream was unable to be parsed at the highest level. The decoder
  /// is unable to proceed. This error \ref SHOULD be treated as fatal to the
  /// stream.
  VPX_CODEC_UNSUP_BITSTREAM(5),

  /// !\brief Encoded bitstream uses an unsupported feature
  ///
  /// The decoder does not implement a feature required by the encoder. This
  /// return code should only be used for features that prevent future
  /// pictures from being properly decoded. This error \ref MAY be treated as
  /// fatal to the stream or \ref MAY be treated as fatal to the current GOP.
  VPX_CODEC_UNSUP_FEATURE(6),

  /// !\brief The coded data for this stream is corrupt or incomplete
  ///
  /// There was a problem decoding the current frame.  This return code
  /// should only be used for failures that prevent future pictures from
  /// being properly decoded. This error \ref MAY be treated as fatal to the
  /// stream or \ref MAY be treated as fatal to the current GOP. If decoding
  /// is continued for the current GOP, artifacts may be present.
  VPX_CODEC_CORRUPT_FRAME(7),

  /// !\brief An application-supplied parameter is not valid.
  VPX_CODEC_INVALID_PARAM(8),

  /// !\brief An iterator reached the end of list.
  VPX_CODEC_LIST_END(9);

  final int value;
  const vpx_codec_err_t(this.value);

  static vpx_codec_err_t fromValue(int value) => switch (value) {
        0 => VPX_CODEC_OK,
        1 => VPX_CODEC_ERROR,
        2 => VPX_CODEC_MEM_ERROR,
        3 => VPX_CODEC_ABI_MISMATCH,
        4 => VPX_CODEC_INCAPABLE,
        5 => VPX_CODEC_UNSUP_BITSTREAM,
        6 => VPX_CODEC_UNSUP_FEATURE,
        7 => VPX_CODEC_CORRUPT_FRAME,
        8 => VPX_CODEC_INVALID_PARAM,
        9 => VPX_CODEC_LIST_END,
        _ => throw ArgumentError('Unknown value for vpx_codec_err_t: $value'),
      };
}

/// ! \brief Codec capabilities bitfield
///
/// Each codec advertises the capabilities it supports as part of its
/// ::vpx_codec_iface_t interface structure. Capabilities are extra interfaces
/// or functionality, and are not required to be supported.
///
/// The available flags are specified by VPX_CODEC_CAP_* defines.
typedef vpx_codec_caps_t = ffi.Long;
typedef Dartvpx_codec_caps_t = int;

/// ! \brief Initialization-time Feature Enabling
///
/// Certain codec features must be known at initialization time, to allow for
/// proper memory allocation.
///
/// The available flags are specified by VPX_CODEC_USE_* defines.
typedef vpx_codec_flags_t = ffi.Long;
typedef Dartvpx_codec_flags_t = int;

final class vpx_codec_iface extends ffi.Opaque {}

/// !\brief Codec interface structure.
///
/// Contains function pointers and other data private to the codec
/// implementation. This structure is opaque to the application.
typedef vpx_codec_iface_t = vpx_codec_iface;

final class vpx_codec_priv extends ffi.Opaque {}

/// !\brief Codec private data structure.
///
/// Contains data private to the codec implementation. This structure is opaque
/// to the application.
typedef vpx_codec_priv_t = vpx_codec_priv;

/// !\brief Iterator
///
/// Opaque storage used for iterating over lists.
typedef vpx_codec_iter_t = ffi.Pointer<ffi.Void>;

/// !\brief Initialization Configurations
///
/// This structure is used to pass init time configuration options to the
/// decoder.
final class vpx_codec_dec_cfg extends ffi.Struct {
  /// < Maximum number of threads to use, default 1
  @ffi.UnsignedInt()
  external int threads;

  /// < Width
  @ffi.UnsignedInt()
  external int w;

  /// < Height
  @ffi.UnsignedInt()
  external int h;
}

/// !\brief Bit depth for codec
/// *
/// This enumeration determines the bit depth of the codec.
enum vpx_bit_depth {
  /// <  8 bits
  VPX_BITS_8(8),

  /// < 10 bits
  VPX_BITS_10(10),

  /// < 12 bits
  VPX_BITS_12(12);

  final int value;
  const vpx_bit_depth(this.value);

  static vpx_bit_depth fromValue(int value) => switch (value) {
        8 => VPX_BITS_8,
        10 => VPX_BITS_10,
        12 => VPX_BITS_12,
        _ => throw ArgumentError('Unknown value for vpx_bit_depth: $value'),
      };
}

/// !\brief Rational Number
///
/// This structure holds a fractional value.
final class vpx_rational extends ffi.Struct {
  /// < fraction numerator
  @ffi.Int()
  external int num;

  /// < fraction denominator
  @ffi.Int()
  external int den;
}

/// !\brief Error Resilient flags
///
/// These flags define which error resilient features to enable in the
/// encoder. The flags are specified through the
/// vpx_codec_enc_cfg::g_error_resilient variable.
typedef vpx_codec_er_flags_t = ffi.Uint32;
typedef Dartvpx_codec_er_flags_t = int;

/// !\brief Multi-pass Encoding Pass
enum vpx_enc_pass {
  /// < Single pass mode
  VPX_RC_ONE_PASS(0),

  /// < First pass of multi-pass mode
  VPX_RC_FIRST_PASS(1),

  /// < Final pass of multi-pass mode
  VPX_RC_LAST_PASS(2);

  final int value;
  const vpx_enc_pass(this.value);

  static vpx_enc_pass fromValue(int value) => switch (value) {
        0 => VPX_RC_ONE_PASS,
        1 => VPX_RC_FIRST_PASS,
        2 => VPX_RC_LAST_PASS,
        _ => throw ArgumentError('Unknown value for vpx_enc_pass: $value'),
      };
}

/// !\brief Rate control mode
enum vpx_rc_mode {
  /// < Variable Bit Rate (VBR) mode
  VPX_VBR(0),

  /// < Constant Bit Rate (CBR) mode
  VPX_CBR(1),

  /// < Constrained Quality (CQ)  mode
  VPX_CQ(2),

  /// < Constant Quality (Q) mode
  VPX_Q(3);

  final int value;
  const vpx_rc_mode(this.value);

  static vpx_rc_mode fromValue(int value) => switch (value) {
        0 => VPX_VBR,
        1 => VPX_CBR,
        2 => VPX_CQ,
        3 => VPX_Q,
        _ => throw ArgumentError('Unknown value for vpx_rc_mode: $value'),
      };
}

/// !\brief Generic fixed size buffer structure
///
/// This structure is able to hold a reference to any fixed size buffer.
final class vpx_fixed_buf extends ffi.Struct {
  /// < Pointer to the data
  external ffi.Pointer<ffi.Void> buf;

  /// < Length of the buffer, in chars
  @ffi.Size()
  external int sz;
}

/// !\brief Generic fixed size buffer structure
///
/// This structure is able to hold a reference to any fixed size buffer.
typedef vpx_fixed_buf_t = vpx_fixed_buf;

/// !\brief Keyframe placement mode.
///
/// This enumeration determines whether keyframes are placed automatically by
/// the encoder or whether this behavior is disabled. Older releases of this
/// SDK were implemented such that VPX_KF_FIXED meant keyframes were disabled.
/// This name is confusing for this behavior, so the new symbols to be used
/// are VPX_KF_AUTO and VPX_KF_DISABLED.
enum vpx_kf_mode {
  /// < deprecated, implies VPX_KF_DISABLED
  VPX_KF_FIXED(0),

  /// < Encoder determines optimal placement automatically
  VPX_KF_AUTO(1);

  /// < Encoder does not place keyframes.
  static const VPX_KF_DISABLED = VPX_KF_FIXED;

  final int value;
  const vpx_kf_mode(this.value);

  static vpx_kf_mode fromValue(int value) => switch (value) {
        0 => VPX_KF_FIXED,
        1 => VPX_KF_AUTO,
        _ => throw ArgumentError('Unknown value for vpx_kf_mode: $value'),
      };

  @override
  String toString() {
    if (this == VPX_KF_FIXED)
      return "vpx_kf_mode.VPX_KF_FIXED, vpx_kf_mode.VPX_KF_DISABLED";
    return super.toString();
  }
}

/// !\brief Rational Number
///
/// This structure holds a fractional value.
typedef vpx_rational_t = vpx_rational;

/// !\brief Encoder configuration structure
///
/// This structure contains the encoder settings that have common representations
/// across all codecs. This doesn't imply that all codecs support all features,
/// however.
final class vpx_codec_enc_cfg extends ffi.Struct {
  /// !\brief Deprecated: Algorithm specific "usage" value
  ///
  /// This value must be zero.
  @ffi.UnsignedInt()
  external int g_usage;

  /// !\brief Maximum number of threads to use
  ///
  /// For multi-threaded implementations, use no more than this number of
  /// threads. The codec may use fewer threads than allowed. The value
  /// 0 is equivalent to the value 1.
  @ffi.UnsignedInt()
  external int g_threads;

  /// < profile of bitstream to use
  @ffi.UnsignedInt()
  external int g_profile;

  /// !\brief Width of the frame
  ///
  /// This value identifies the presentation resolution of the frame,
  /// in pixels. Note that the frames passed as input to the encoder must
  /// have this resolution. Frames will be presented by the decoder in this
  /// resolution, independent of any spatial resampling the encoder may do.
  @ffi.UnsignedInt()
  external int g_w;

  /// !\brief Height of the frame
  ///
  /// This value identifies the presentation resolution of the frame,
  /// in pixels. Note that the frames passed as input to the encoder must
  /// have this resolution. Frames will be presented by the decoder in this
  /// resolution, independent of any spatial resampling the encoder may do.
  @ffi.UnsignedInt()
  external int g_h;

  /// !\brief Bit-depth of the codec
  ///
  /// This value identifies the bit_depth of the codec,
  /// Only certain bit-depths are supported as identified in the
  /// vpx_bit_depth_t enum.
  @ffi.UnsignedInt()
  external int g_bit_depthAsInt;

  vpx_bit_depth get g_bit_depth => vpx_bit_depth.fromValue(g_bit_depthAsInt);

  /// !\brief Bit-depth of the input frames
  ///
  /// This value identifies the bit_depth of the input frames in bits.
  /// Note that the frames passed as input to the encoder must have
  /// this bit-depth.
  @ffi.UnsignedInt()
  external int g_input_bit_depth;

  /// !\brief Stream timebase units
  ///
  /// Indicates the smallest interval of time, in seconds, used by the stream.
  /// For fixed frame rate material, or variable frame rate material where
  /// frames are timed at a multiple of a given clock (ex: video capture),
  /// the \ref RECOMMENDED method is to set the timebase to the reciprocal
  /// of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the
  /// pts to correspond to the frame number, which can be handy. For
  /// re-encoding video from containers with absolute time timestamps, the
  /// \ref RECOMMENDED method is to set the timebase to that of the parent
  /// container or multimedia framework (ex: 1/1000 for ms, as in FLV).
  external vpx_rational g_timebase;

  /// !\brief Enable error resilient modes.
  ///
  /// The error resilient bitfield indicates to the encoder which features
  /// it should enable to take measures for streaming over lossy or noisy
  /// links.
  @vpx_codec_er_flags_t()
  external int g_error_resilient;

  /// !\brief Multi-pass Encoding Mode
  ///
  /// This value should be set to the current phase for multi-pass encoding.
  /// For single pass, set to #VPX_RC_ONE_PASS.
  @ffi.UnsignedInt()
  external int g_passAsInt;

  vpx_enc_pass get g_pass => vpx_enc_pass.fromValue(g_passAsInt);

  /// !\brief Allow lagged encoding
  ///
  /// If set, this value allows the encoder to consume a number of input
  /// frames before producing output frames. This allows the encoder to
  /// base decisions for the current frame on future frames. This does
  /// increase the latency of the encoding pipeline, so it is not appropriate
  /// in all situations (ex: realtime encoding).
  ///
  /// Note that this is a maximum value -- the encoder may produce frames
  /// sooner than the given limit. Set this value to 0 to disable this
  /// feature.
  @ffi.UnsignedInt()
  external int g_lag_in_frames;

  /// !\brief Temporal resampling configuration, if supported by the codec.
  ///
  /// Temporal resampling allows the codec to "drop" frames as a strategy to
  /// meet its target data rate. This can cause temporal discontinuities in
  /// the encoded video, which may appear as stuttering during playback. This
  /// trade-off is often acceptable, but for many applications is not. It can
  /// be disabled in these cases.
  ///
  /// This threshold is described as a percentage of the target data buffer.
  /// When the data buffer falls below this percentage of fullness, a
  /// dropped frame is indicated. Set the threshold to zero (0) to disable
  /// this feature.
  @ffi.UnsignedInt()
  external int rc_dropframe_thresh;

  /// !\brief Enable/disable spatial resampling, if supported by the codec.
  ///
  /// Spatial resampling allows the codec to compress a lower resolution
  /// version of the frame, which is then upscaled by the encoder to the
  /// correct presentation resolution. This increases visual quality at
  /// low data rates, at the expense of CPU time on the encoder/decoder.
  @ffi.UnsignedInt()
  external int rc_resize_allowed;

  /// !\brief Internal coded frame width.
  ///
  /// If spatial resampling is enabled this specifies the width of the
  /// encoded frame.
  @ffi.UnsignedInt()
  external int rc_scaled_width;

  /// !\brief Internal coded frame height.
  ///
  /// If spatial resampling is enabled this specifies the height of the
  /// encoded frame.
  @ffi.UnsignedInt()
  external int rc_scaled_height;

  /// !\brief Spatial resampling up watermark.
  ///
  /// This threshold is described as a percentage of the target data buffer.
  /// When the data buffer rises above this percentage of fullness, the
  /// encoder will step up to a higher resolution version of the frame.
  @ffi.UnsignedInt()
  external int rc_resize_up_thresh;

  /// !\brief Spatial resampling down watermark.
  ///
  /// This threshold is described as a percentage of the target data buffer.
  /// When the data buffer falls below this percentage of fullness, the
  /// encoder will step down to a lower resolution version of the frame.
  @ffi.UnsignedInt()
  external int rc_resize_down_thresh;

  /// !\brief Rate control algorithm to use.
  ///
  /// Indicates whether the end usage of this stream is to be streamed over
  /// a bandwidth constrained link, indicating that Constant Bit Rate (CBR)
  /// mode should be used, or whether it will be played back on a high
  /// bandwidth link, as from a local disk, where higher variations in
  /// bitrate are acceptable.
  @ffi.UnsignedInt()
  external int rc_end_usageAsInt;

  vpx_rc_mode get rc_end_usage => vpx_rc_mode.fromValue(rc_end_usageAsInt);

  /// !\brief Two-pass stats buffer.
  ///
  /// A buffer containing all of the stats packets produced in the first
  /// pass, concatenated.
  external vpx_fixed_buf_t rc_twopass_stats_in;

  /// !\brief first pass mb stats buffer.
  ///
  /// A buffer containing all of the first pass mb stats packets produced
  /// in the first pass, concatenated.
  external vpx_fixed_buf_t rc_firstpass_mb_stats_in;

  /// !\brief Target data rate
  ///
  /// Target bitrate to use for this stream, in kilobits per second.
  @ffi.UnsignedInt()
  external int rc_target_bitrate;

  /// !\brief Minimum (Best Quality) Quantizer
  ///
  /// The quantizer is the most direct control over the quality of the
  /// encoded image. The range of valid values for the quantizer is codec
  /// specific. Consult the documentation for the codec to determine the
  /// values to use.
  @ffi.UnsignedInt()
  external int rc_min_quantizer;

  /// !\brief Maximum (Worst Quality) Quantizer
  ///
  /// The quantizer is the most direct control over the quality of the
  /// encoded image. The range of valid values for the quantizer is codec
  /// specific. Consult the documentation for the codec to determine the
  /// values to use.
  @ffi.UnsignedInt()
  external int rc_max_quantizer;

  /// !\brief Rate control adaptation undershoot control
  ///
  /// VP8: Expressed as a percentage of the target bitrate,
  /// controls the maximum allowed adaptation speed of the codec.
  /// This factor controls the maximum amount of bits that can
  /// be subtracted from the target bitrate in order to compensate
  /// for prior overshoot.
  /// VP9: Expressed as a percentage of the target bitrate, a threshold
  /// undershoot level (current rate vs target) beyond which more aggressive
  /// corrective measures are taken.
  /// *
  /// Valid values in the range VP8:0-100 VP9: 0-100.
  @ffi.UnsignedInt()
  external int rc_undershoot_pct;

  /// !\brief Rate control adaptation overshoot control
  ///
  /// VP8: Expressed as a percentage of the target bitrate,
  /// controls the maximum allowed adaptation speed of the codec.
  /// This factor controls the maximum amount of bits that can
  /// be added to the target bitrate in order to compensate for
  /// prior undershoot.
  /// VP9: Expressed as a percentage of the target bitrate, a threshold
  /// overshoot level (current rate vs target) beyond which more aggressive
  /// corrective measures are taken.
  ///
  /// Valid values in the range VP8:0-100 VP9: 0-100.
  @ffi.UnsignedInt()
  external int rc_overshoot_pct;

  /// !\brief Decoder Buffer Size
  ///
  /// This value indicates the amount of data that may be buffered by the
  /// decoding application. Note that this value is expressed in units of
  /// time (milliseconds). For example, a value of 5000 indicates that the
  /// client will buffer (at least) 5000ms worth of encoded data. Use the
  /// target bitrate (#rc_target_bitrate) to convert to bits/bytes, if
  /// necessary.
  @ffi.UnsignedInt()
  external int rc_buf_sz;

  /// !\brief Decoder Buffer Initial Size
  ///
  /// This value indicates the amount of data that will be buffered by the
  /// decoding application prior to beginning playback. This value is
  /// expressed in units of time (milliseconds). Use the target bitrate
  /// (#rc_target_bitrate) to convert to bits/bytes, if necessary.
  @ffi.UnsignedInt()
  external int rc_buf_initial_sz;

  /// !\brief Decoder Buffer Optimal Size
  ///
  /// This value indicates the amount of data that the encoder should try
  /// to maintain in the decoder's buffer. This value is expressed in units
  /// of time (milliseconds). Use the target bitrate (#rc_target_bitrate)
  /// to convert to bits/bytes, if necessary.
  @ffi.UnsignedInt()
  external int rc_buf_optimal_sz;

  /// !\brief Two-pass mode CBR/VBR bias
  ///
  /// Bias, expressed on a scale of 0 to 100, for determining target size
  /// for the current frame. The value 0 indicates the optimal CBR mode
  /// value should be used. The value 100 indicates the optimal VBR mode
  /// value should be used. Values in between indicate which way the
  /// encoder should "lean."
  @ffi.UnsignedInt()
  external int rc_2pass_vbr_bias_pct;

  /// !\brief Two-pass mode per-GOP minimum bitrate
  ///
  /// This value, expressed as a percentage of the target bitrate, indicates
  /// the minimum bitrate to be used for a single GOP (aka "section")
  @ffi.UnsignedInt()
  external int rc_2pass_vbr_minsection_pct;

  /// !\brief Two-pass mode per-GOP maximum bitrate
  ///
  /// This value, expressed as a percentage of the target bitrate, indicates
  /// the maximum bitrate to be used for a single GOP (aka "section")
  @ffi.UnsignedInt()
  external int rc_2pass_vbr_maxsection_pct;

  /// !\brief Two-pass corpus vbr mode complexity control
  /// Used only in VP9: A value representing the corpus midpoint complexity
  /// for corpus vbr mode. This value defaults to 0 which disables corpus vbr
  /// mode in favour of normal vbr mode.
  @ffi.UnsignedInt()
  external int rc_2pass_vbr_corpus_complexity;

  /// !\brief Keyframe placement mode
  ///
  /// This value indicates whether the encoder should place keyframes at a
  /// fixed interval, or determine the optimal placement automatically
  /// (as governed by the #kf_min_dist and #kf_max_dist parameters)
  @ffi.UnsignedInt()
  external int kf_modeAsInt;

  vpx_kf_mode get kf_mode => vpx_kf_mode.fromValue(kf_modeAsInt);

  /// !\brief Keyframe minimum interval
  ///
  /// This value, expressed as a number of frames, prevents the encoder from
  /// placing a keyframe nearer than kf_min_dist to the previous keyframe. At
  /// least kf_min_dist frames non-keyframes will be coded before the next
  /// keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval.
  @ffi.UnsignedInt()
  external int kf_min_dist;

  /// !\brief Keyframe maximum interval
  ///
  /// This value, expressed as a number of frames, forces the encoder to code
  /// a keyframe if one has not been coded in the last kf_max_dist frames.
  /// A value of 0 implies all frames will be keyframes. Set kf_min_dist
  /// equal to kf_max_dist for a fixed interval.
  @ffi.UnsignedInt()
  external int kf_max_dist;

  /// !\brief Number of spatial coding layers.
  ///
  /// This value specifies the number of spatial coding layers to be used.
  @ffi.UnsignedInt()
  external int ss_number_layers;

  /// !\brief Enable auto alt reference flags for each spatial layer.
  ///
  /// These values specify if auto alt reference frame is enabled for each
  /// spatial layer.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> ss_enable_auto_alt_ref;

  /// !\brief Target bitrate for each spatial layer.
  ///
  /// These values specify the target coding bitrate to be used for each
  /// spatial layer. (in kbps)
  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> ss_target_bitrate;

  /// !\brief Number of temporal coding layers.
  ///
  /// This value specifies the number of temporal layers to be used.
  @ffi.UnsignedInt()
  external int ts_number_layers;

  /// !\brief Target bitrate for each temporal layer.
  ///
  /// These values specify the target coding bitrate to be used for each
  /// temporal layer. (in kbps)
  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> ts_target_bitrate;

  /// !\brief Frame rate decimation factor for each temporal layer.
  ///
  /// These values specify the frame rate decimation factors to apply
  /// to each temporal layer.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> ts_rate_decimator;

  /// !\brief Length of the sequence defining frame temporal layer membership.
  ///
  /// This value specifies the length of the sequence that defines the
  /// membership of frames to temporal layers. For example, if the
  /// ts_periodicity = 8, then the frames are assigned to coding layers with a
  /// repeated sequence of length 8.
  @ffi.UnsignedInt()
  external int ts_periodicity;

  /// !\brief Template defining the membership of frames to temporal layers.
  ///
  /// This array defines the membership of frames to temporal coding layers.
  /// For a 2-layer encoding that assigns even numbered frames to one temporal
  /// layer (0) and odd numbered frames to a second temporal layer (1) with
  /// ts_periodicity=8, then ts_layer_id = (0,1,0,1,0,1,0,1).
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedInt> ts_layer_id;

  /// !\brief Target bitrate for each spatial/temporal layer.
  ///
  /// These values specify the target coding bitrate to be used for each
  /// spatial/temporal layer. (in kbps)
  @ffi.Array.multi([12])
  external ffi.Array<ffi.UnsignedInt> layer_target_bitrate;

  /// !\brief Temporal layering mode indicating which temporal layering scheme to
  /// use.
  ///
  /// The value (refer to VP9E_TEMPORAL_LAYERING_MODE) specifies the
  /// temporal layering mode to use.
  @ffi.Int()
  external int temporal_layering_mode;

  /// !\brief A flag indicating whether to use external rate control parameters.
  /// By default is 0. If set to 1, the following parameters will be used in the
  /// rate control system.
  @ffi.Int()
  external int use_vizier_rc_params;

  /// !\brief Active worst quality factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t active_wq_factor;

  /// !\brief Error per macroblock adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t err_per_mb_factor;

  /// !\brief Second reference default decay limit.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t sr_default_decay_limit;

  /// !\brief Second reference difference factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t sr_diff_factor;

  /// !\brief Keyframe error per macroblock adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t kf_err_per_mb_factor;

  /// !\brief Keyframe minimum boost adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t kf_frame_min_boost_factor;

  /// !\brief Keyframe maximum boost adjustment factor, for the first keyframe
  /// in a chunk.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t kf_frame_max_boost_first_factor;

  /// !\brief Keyframe maximum boost adjustment factor, for subsequent keyframes.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t kf_frame_max_boost_subs_factor;

  /// !\brief Keyframe maximum total boost adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t kf_max_total_boost_factor;

  /// !\brief Golden frame maximum total boost adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t gf_max_total_boost_factor;

  /// !\brief Golden frame maximum boost adjustment factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t gf_frame_max_boost_factor;

  /// !\brief Zero motion power factor.
  ///
  /// Rate control parameters, set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t zm_factor;

  /// !\brief Rate-distortion multiplier for inter frames.
  /// The multiplier is a crucial parameter in the calculation of rate distortion
  /// cost. It is often related to the qp (qindex) value.
  /// Rate control parameters, could be set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t rd_mult_inter_qp_fac;

  /// !\brief Rate-distortion multiplier for alt-ref frames.
  /// The multiplier is a crucial parameter in the calculation of rate distortion
  /// cost. It is often related to the qp (qindex) value.
  /// Rate control parameters, could be set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t rd_mult_arf_qp_fac;

  /// !\brief Rate-distortion multiplier for key frames.
  /// The multiplier is a crucial parameter in the calculation of rate distortion
  /// cost. It is often related to the qp (qindex) value.
  /// Rate control parameters, could be set from external experiment results.
  /// Only when |use_vizier_rc_params| is set to 1, the pass in value will be
  /// used. Otherwise, the default value is used.
  external vpx_rational_t rd_mult_key_qp_fac;
}

final class UnnamedUnion1 extends ffi.Union {
  external ffi.Pointer<vpx_codec_dec_cfg> dec;

  external ffi.Pointer<vpx_codec_enc_cfg> enc;

  external ffi.Pointer<ffi.Void> raw;
}

/// !\brief Codec context structure
///
/// All codecs \ref MUST support this context structure fully. In general,
/// this data should be considered private to the codec algorithm, and
/// not be manipulated or examined by the calling application. Applications
/// may reference the 'name' member to get a printable description of the
/// algorithm.
final class vpx_codec_ctx extends ffi.Struct {
  /// < Printable interface name
  external ffi.Pointer<ffi.Char> name;

  /// < Interface pointers
  external ffi.Pointer<vpx_codec_iface_t> iface;

  /// < Last returned error
  @ffi.UnsignedInt()
  external int errAsInt;

  vpx_codec_err_t get err => vpx_codec_err_t.fromValue(errAsInt);

  /// < Detailed info, if available
  external ffi.Pointer<ffi.Char> err_detail;

  /// < Flags passed at init time
  @vpx_codec_flags_t()
  external int init_flags;

  /// < Configuration pointer aliasing union
  external UnnamedUnion1 config;

  /// < Algorithm private storage
  external ffi.Pointer<vpx_codec_priv_t> priv;
}

/// !\brief Codec context structure
///
/// All codecs \ref MUST support this context structure fully. In general,
/// this data should be considered private to the codec algorithm, and
/// not be manipulated or examined by the calling application. Applications
/// may reference the 'name' member to get a printable description of the
/// algorithm.
typedef vpx_codec_ctx_t = vpx_codec_ctx;

/// !\brief Control functions
///
/// The set of macros define the control functions of VP8 interface
enum vp8_com_control_id {
  /// !\brief pass in an external frame into decoder to be used as reference frame
  VP8_SET_REFERENCE(1),

  /// < get a copy of reference frame from the decoder
  VP8_COPY_REFERENCE(2),

  /// < set the decoder's post processing settings
  VP8_SET_POSTPROC(3),

  /// < get a pointer to a reference frame
  VP9_GET_REFERENCE(128),
  VP8_COMMON_CTRL_ID_MAX(129),
  VP8_DECODER_CTRL_ID_START(256);

  final int value;
  const vp8_com_control_id(this.value);

  static vp8_com_control_id fromValue(int value) => switch (value) {
        1 => VP8_SET_REFERENCE,
        2 => VP8_COPY_REFERENCE,
        3 => VP8_SET_POSTPROC,
        128 => VP9_GET_REFERENCE,
        129 => VP8_COMMON_CTRL_ID_MAX,
        256 => VP8_DECODER_CTRL_ID_START,
        _ =>
          throw ArgumentError('Unknown value for vp8_com_control_id: $value'),
      };
}

/// !\brief post process flags
///
/// The set of macros define VP8 decoder post processing flags
enum vp8_postproc_level {
  VP8_NOFILTERING(0),
  VP8_DEBLOCK(1),
  VP8_DEMACROBLOCK(2),
  VP8_ADDNOISE(4),
  VP8_MFQE(8);

  final int value;
  const vp8_postproc_level(this.value);

  static vp8_postproc_level fromValue(int value) => switch (value) {
        0 => VP8_NOFILTERING,
        1 => VP8_DEBLOCK,
        2 => VP8_DEMACROBLOCK,
        4 => VP8_ADDNOISE,
        8 => VP8_MFQE,
        _ =>
          throw ArgumentError('Unknown value for vp8_postproc_level: $value'),
      };
}

/// !\brief post process flags
///
/// This define a structure that describe the post processing settings. For
/// the best objective measure (using the PSNR metric) set post_proc_flag
/// to VP8_DEBLOCK and deblocking_level to 1.
final class vp8_postproc_cfg extends ffi.Struct {
  /// !\brief the types of post processing to be done, should be combination of
  /// "vp8_postproc_level"
  @ffi.Int()
  external int post_proc_flag;

  /// < the strength of deblocking, valid range [0, 16]
  @ffi.Int()
  external int deblocking_level;

  /// < the strength of additive noise, valid range [0, 16]
  @ffi.Int()
  external int noise_level;
}

/// !\brief post process flags
///
/// This define a structure that describe the post processing settings. For
/// the best objective measure (using the PSNR metric) set post_proc_flag
/// to VP8_DEBLOCK and deblocking_level to 1.
typedef vp8_postproc_cfg_t = vp8_postproc_cfg;

/// !\brief reference frame type
///
/// The set of macros define the type of VP8 reference frames
enum vpx_ref_frame_type {
  VP8_LAST_FRAME(1),
  VP8_GOLD_FRAME(2),
  VP8_ALTR_FRAME(4);

  final int value;
  const vpx_ref_frame_type(this.value);

  static vpx_ref_frame_type fromValue(int value) => switch (value) {
        1 => VP8_LAST_FRAME,
        2 => VP8_GOLD_FRAME,
        4 => VP8_ALTR_FRAME,
        _ =>
          throw ArgumentError('Unknown value for vpx_ref_frame_type: $value'),
      };
}

/// !\brief reference frame data struct
///
/// Define the data struct to access vp8 reference frames.
final class vpx_ref_frame extends ffi.Struct {
  /// < which reference frame
  @ffi.UnsignedInt()
  external int frame_typeAsInt;

  vpx_ref_frame_type get frame_type =>
      vpx_ref_frame_type.fromValue(frame_typeAsInt);

  /// < reference frame data in image format
  external vpx_image_t img;
}

/// !\brief reference frame data struct
///
/// Define the data struct to access vp8 reference frames.
typedef vpx_ref_frame_t = vpx_ref_frame;

/// !\brief VP9 specific reference frame data struct
///
/// Define the data struct to access vp9 reference frames.
final class vp9_ref_frame extends ffi.Struct {
  /// < frame index to get (input)
  @ffi.Int()
  external int idx;

  /// < img structure to populate (output)
  external vpx_image_t img;
}

/// !\brief VP9 specific reference frame data struct
///
/// Define the data struct to access vp9 reference frames.
typedef vp9_ref_frame_t = vp9_ref_frame;

/// !\brief Temporal dependency model stats for each block before propagation
final class VpxTplBlockStats extends ffi.Struct {
  /// < Pixel row of the top left corner
  @ffi.Int16()
  external int row;

  /// < Pixel col of the top left corner
  @ffi.Int16()
  external int col;

  /// < Intra cost
  @ffi.Int64()
  external int intra_cost;

  /// < Inter cost
  @ffi.Int64()
  external int inter_cost;

  /// < Motion vector row
  @ffi.Int16()
  external int mv_r;

  /// < Motion vector col
  @ffi.Int16()
  external int mv_c;

  /// < Rate from reconstructed ref frame
  @ffi.Int64()
  external int recrf_rate;

  /// < Distortion from reconstructed ref frame
  @ffi.Int64()
  external int recrf_dist;

  /// < Ref frame index in the ref frame buffer
  @ffi.Int()
  external int ref_frame_index;
}

/// !\brief Temporal dependency model stats for each frame before propagation
final class VpxTplFrameStats extends ffi.Struct {
  /// < Frame width
  @ffi.Int()
  external int frame_width;

  /// < Frame height
  @ffi.Int()
  external int frame_height;

  /// < Number of blocks. Size of block_stats_list
  @ffi.Int()
  external int num_blocks;

  /// < List of tpl stats for each block
  external ffi.Pointer<VpxTplBlockStats> block_stats_list;
}

/// !\brief Temporal dependency model stats for each GOP before propagation
final class VpxTplGopStats extends ffi.Struct {
  /// < GOP size, also the size of frame_stats_list.
  @ffi.Int()
  external int size;

  /// < List of tpl stats for each frame
  external ffi.Pointer<VpxTplFrameStats> frame_stats_list;
}

final class _iobuf extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

typedef FILE = _iobuf;

/// !\brief The control type of the inference API.
/// In VPX_RC_QP mode, the external rate control model determines the
/// quantization parameter (QP) for each frame.
/// In VPX_RC_GOP mode, the external rate control model determines the
/// group of picture (GOP) of the video sequence.
/// In VPX_RC_RDMULT mode, the external rate control model determines the
/// rate-distortion multiplier (rdmult) for the current frame.
/// In VPX_RC_GOP_QP mode, the external rate control model determines
/// both the QP and the GOP.
/// In VPX_RC_GOP_QP_RDMULT mode, the external rate control model determines
/// the QP, GOP and the rdmult.
enum vpx_rc_type {
  VPX_RC_QP(1),
  VPX_RC_GOP(2),
  VPX_RC_RDMULT(4),
  VPX_RC_GOP_QP(3),
  VPX_RC_GOP_QP_RDMULT(7);

  final int value;
  const vpx_rc_type(this.value);

  static vpx_rc_type fromValue(int value) => switch (value) {
        1 => VPX_RC_QP,
        2 => VPX_RC_GOP,
        4 => VPX_RC_RDMULT,
        3 => VPX_RC_GOP_QP,
        7 => VPX_RC_GOP_QP_RDMULT,
        _ => throw ArgumentError('Unknown value for vpx_rc_type: $value'),
      };
}

/// !\brief The rate control mode for the external rate control model.
enum vpx_ext_rc_mode {
  VPX_RC_QMODE(0),
  VPX_RC_VBR(1),
  VPX_RC_CQ(2);

  final int value;
  const vpx_ext_rc_mode(this.value);

  static vpx_ext_rc_mode fromValue(int value) => switch (value) {
        0 => VPX_RC_QMODE,
        1 => VPX_RC_VBR,
        2 => VPX_RC_CQ,
        _ => throw ArgumentError('Unknown value for vpx_ext_rc_mode: $value'),
      };
}

/// !\brief Abstract rate control model handler
///
/// The encoder will receive the model handler from create_model() defined in
/// vpx_rc_funcs_t.
typedef vpx_rc_model_t = ffi.Pointer<ffi.Void>;

/// !\brief Encode frame decision made by the external rate control model
///
/// The encoder will receive the decision from the external rate control model
/// through get_encodeframe_decision() defined in vpx_rc_funcs_t.
///
/// If q_index = VPX_DEFAULT_Q, the encoder will use libvpx's default q.
///
/// If max_frame_size = 0, the encoding ignores max frame size limit.
/// If max_frame_size = -1, the encoding uses VP9's max frame size as the limit.
/// If the encoded frame size is larger than max_frame_size, the frame is
/// recoded to meet the size limit, following VP9's recoding principles.
final class vpx_rc_encodeframe_decision extends ffi.Struct {
  /// < Quantizer step index [0..255]
  @ffi.Int()
  external int q_index;

  /// < Maximal frame size allowed to encode a frame
  @ffi.Int()
  external int max_frame_size;
}

/// !\brief Encode frame decision made by the external rate control model
///
/// The encoder will receive the decision from the external rate control model
/// through get_encodeframe_decision() defined in vpx_rc_funcs_t.
///
/// If q_index = VPX_DEFAULT_Q, the encoder will use libvpx's default q.
///
/// If max_frame_size = 0, the encoding ignores max frame size limit.
/// If max_frame_size = -1, the encoding uses VP9's max frame size as the limit.
/// If the encoded frame size is larger than max_frame_size, the frame is
/// recoded to meet the size limit, following VP9's recoding principles.
typedef vpx_rc_encodeframe_decision_t = vpx_rc_encodeframe_decision;

/// !\brief Information for the frame to be encoded.
///
/// The encoder will send the information to external rate control model through
/// get_encodeframe_decision() defined in vpx_rc_funcs_t.
final class vpx_rc_encodeframe_info extends ffi.Struct {
  /// !
  /// 0: Key frame
  /// 1: Inter frame
  /// 2: Alternate reference frame
  /// 3: Overlay frame
  /// 4: Golden frame
  @ffi.Int()
  external int frame_type;

  /// < display index, starts from zero
  @ffi.Int()
  external int show_index;

  /// < coding index, starts from zero
  @ffi.Int()
  external int coding_index;

  /// !
  /// index of the current frame in this group of picture, starts from zero.
  @ffi.Int()
  external int gop_index;

  /// < three reference frames' coding indices
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int> ref_frame_coding_indexes;

  /// !
  /// The validity of the three reference frames.
  /// 0: Invalid
  /// 1: Valid
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int> ref_frame_valid_list;

  /// !
  /// The length of the current GOP.
  @ffi.Int()
  external int gop_size;

  /// !
  /// Whether the current GOP uses an alt ref.
  @ffi.Int()
  external int use_alt_ref;
}

/// !\brief Information for the frame to be encoded.
///
/// The encoder will send the information to external rate control model through
/// get_encodeframe_decision() defined in vpx_rc_funcs_t.
typedef vpx_rc_encodeframe_info_t = vpx_rc_encodeframe_info;

/// !\brief Frame coding result
///
/// The encoder will send the result to the external rate control model through
/// update_encodeframe_result() defined in vpx_rc_funcs_t.
final class vpx_rc_encodeframe_result extends ffi.Struct {
  /// < sum of squared error of the reconstructed frame
  @ffi.Int64()
  external int sse;

  /// < number of bits spent on coding the frame
  @ffi.Int64()
  external int bit_count;

  /// < number of pixels in YUV planes of the frame
  @ffi.Int64()
  external int pixel_count;

  /// < the actual qindex used to encode the frame
  @ffi.Int()
  external int actual_encoding_qindex;
}

/// !\brief Frame coding result
///
/// The encoder will send the result to the external rate control model through
/// update_encodeframe_result() defined in vpx_rc_funcs_t.
typedef vpx_rc_encodeframe_result_t = vpx_rc_encodeframe_result;

/// !\brief Status returned by rate control callback functions.
enum vpx_rc_status {
  VPX_RC_OK(0),
  VPX_RC_ERROR(1);

  final int value;
  const vpx_rc_status(this.value);

  static vpx_rc_status fromValue(int value) => switch (value) {
        0 => VPX_RC_OK,
        1 => VPX_RC_ERROR,
        _ => throw ArgumentError('Unknown value for vpx_rc_status: $value'),
      };
}

/// !\brief First pass frame stats
/// This is a mirror of vp9's FIRSTPASS_STATS except that spatial_layer_id is
/// omitted
final class vpx_rc_frame_stats extends ffi.Struct {
  /// !
  /// Frame number in display order, if stats are for a single frame.
  /// No real meaning for a collection of frames.
  @ffi.Double()
  external double frame;

  /// !
  /// Weight assigned to this frame (or total weight for the collection of
  /// frames) currently based on intra factor and brightness factor. This is used
  /// to distribute bits between easier and harder frames.
  @ffi.Double()
  external double weight;

  /// !
  /// Intra prediction error.
  @ffi.Double()
  external double intra_error;

  /// !
  /// Best of intra pred error and inter pred error using last frame as ref.
  @ffi.Double()
  external double coded_error;

  /// !
  /// Best of intra pred error and inter pred error using golden frame as ref.
  @ffi.Double()
  external double sr_coded_error;

  /// !
  /// Estimate the noise energy of the current frame.
  @ffi.Double()
  external double frame_noise_energy;

  /// !
  /// Percentage of blocks with inter pred error < intra pred error.
  @ffi.Double()
  external double pcnt_inter;

  /// !
  /// Percentage of blocks using (inter prediction and) non-zero motion vectors.
  @ffi.Double()
  external double pcnt_motion;

  /// !
  /// Percentage of blocks where golden frame was better than last or intra:
  /// inter pred error using golden frame < inter pred error using last frame and
  /// inter pred error using golden frame < intra pred error
  @ffi.Double()
  external double pcnt_second_ref;

  /// !
  /// Percentage of blocks where intra and inter prediction errors were very
  /// close.
  @ffi.Double()
  external double pcnt_neutral;

  /// !
  /// Percentage of blocks that have intra error < inter error and inter error <
  /// LOW_I_THRESH
  /// - bit_depth 8: LOW_I_THRESH = 24000
  /// - bit_depth 10: LOW_I_THRESH = 24000 << 4
  /// - bit_depth 12: LOW_I_THRESH = 24000 << 8
  @ffi.Double()
  external double pcnt_intra_low;

  /// !
  /// Percentage of blocks that have intra error < inter error and intra error <
  /// LOW_I_THRESH but inter error >= LOW_I_THRESH LOW_I_THRESH
  /// - bit_depth 8: LOW_I_THRESH = 24000
  /// - bit_depth 10: LOW_I_THRESH = 24000 << 4
  /// - bit_depth 12: LOW_I_THRESH = 24000 << 8
  @ffi.Double()
  external double pcnt_intra_high;

  /// !
  /// Percentage of blocks that have almost no intra error residual
  /// (i.e. are in effect completely flat and untextured in the intra
  /// domain). In natural videos this is uncommon, but it is much more
  /// common in animations, graphics and screen content, so may be used
  /// as a signal to detect these types of content.
  @ffi.Double()
  external double intra_skip_pct;

  /// !
  /// Percentage of blocks that have intra error < SMOOTH_INTRA_THRESH
  /// - bit_depth 8:  SMOOTH_INTRA_THRESH = 4000
  /// - bit_depth 10: SMOOTH_INTRA_THRESH = 4000 << 4
  /// - bit_depth 12: SMOOTH_INTRA_THRESH = 4000 << 8
  @ffi.Double()
  external double intra_smooth_pct;

  /// !
  /// Image mask rows top and bottom.
  @ffi.Double()
  external double inactive_zone_rows;

  /// !
  /// Image mask columns at left and right edges.
  @ffi.Double()
  external double inactive_zone_cols;

  /// !
  /// Mean of row motion vectors.
  @ffi.Double()
  external double MVr;

  /// !
  /// Mean of absolute value of row motion vectors.
  @ffi.Double()
  external double mvr_abs;

  /// !
  /// Mean of column motion vectors.
  @ffi.Double()
  external double MVc;

  /// !
  /// Mean of absolute value of column motion vectors.
  @ffi.Double()
  external double mvc_abs;

  /// !
  /// Variance of row motion vectors.
  @ffi.Double()
  external double MVrv;

  /// !
  /// Variance of column motion vectors.
  @ffi.Double()
  external double MVcv;

  /// !
  /// Value in range [-1,1] indicating fraction of row and column motion vectors
  /// that point inwards (negative MV value) or outwards (positive MV value).
  /// For example, value of 1 indicates, all row/column MVs are inwards.
  @ffi.Double()
  external double mv_in_out_count;

  /// !
  /// Duration of the frame / collection of frames.
  @ffi.Double()
  external double duration;

  /// !
  /// 1.0 if stats are for a single frame, or
  /// number of frames whose stats are accumulated.
  @ffi.Double()
  external double count;

  /// !
  /// Number of new mv in a frame.
  @ffi.Double()
  external double new_mv_count;
}

/// !\brief First pass frame stats
/// This is a mirror of vp9's FIRSTPASS_STATS except that spatial_layer_id is
/// omitted
typedef vpx_rc_frame_stats_t = vpx_rc_frame_stats;

/// !\brief Collection of first pass frame stats
final class vpx_rc_firstpass_stats extends ffi.Struct {
  /// !
  /// Pointer to first pass frame stats.
  /// The pointed array of vpx_rc_frame_stats_t should have length equal to
  /// number of show frames in the video.
  external ffi.Pointer<vpx_rc_frame_stats_t> frame_stats;

  /// !
  /// Number of show frames in the video.
  @ffi.Int()
  external int num_frames;
}

/// !\brief Collection of first pass frame stats
typedef vpx_rc_firstpass_stats_t = vpx_rc_firstpass_stats;

/// !\brief Encode config sent to external rate control model
final class vpx_rc_config extends ffi.Struct {
  /// < frame width
  @ffi.Int()
  external int frame_width;

  /// < frame height
  @ffi.Int()
  external int frame_height;

  /// < number of visible frames in the video
  @ffi.Int()
  external int show_frame_count;

  /// < max GOP size in number of show frames
  @ffi.Int()
  external int max_gf_interval;

  /// < min GOP size in number of show frames
  @ffi.Int()
  external int min_gf_interval;

  /// !
  /// Target bitrate in kilobytes per second
  @ffi.Int()
  external int target_bitrate_kbps;

  /// < numerator of frame rate
  @ffi.Int()
  external int frame_rate_num;

  /// < denominator of frame rate
  @ffi.Int()
  external int frame_rate_den;

  /// < Q mode or VBR mode
  @ffi.UnsignedInt()
  external int rc_modeAsInt;

  vpx_ext_rc_mode get rc_mode => vpx_ext_rc_mode.fromValue(rc_modeAsInt);

  /// < for VBR mode only
  @ffi.Int()
  external int overshoot_percent;

  /// < for VBR mode only
  @ffi.Int()
  external int undershoot_percent;
}

/// !\brief Encode config sent to external rate control model
typedef vpx_rc_config_t = vpx_rc_config;

/// !\brief Information passed to the external rate control model to
/// help make GOP decisions.
final class vpx_rc_gop_info extends ffi.Struct {
  /// !
  /// Minimum allowed gf interval, fixed for the whole clip.
  /// Note that it will be modified to match vp9's level constraints
  /// in the encoder.
  /// The level constraint is defined in vp9_encoder.c:
  /// const Vp9LevelSpec vp9_level_defs[VP9_LEVELS].
  @ffi.Int()
  external int min_gf_interval;

  /// !
  /// Maximum allowed gf interval, fixed for the whole clip.
  @ffi.Int()
  external int max_gf_interval;

  /// !
  /// Minimum allowed gf interval for the current GOP, determined
  /// by the encoder.
  @ffi.Int()
  external int active_min_gf_interval;

  /// !
  /// Maximum allowed gf interval for the current GOP, determined
  /// by the encoder.
  @ffi.Int()
  external int active_max_gf_interval;

  /// !
  /// Whether to allow the use of alt ref, determined by the encoder.
  /// It is fixed for the entire encode.
  /// See function "is_altref_enabled" in vp9_encoder.h.
  @ffi.Int()
  external int allow_alt_ref;

  /// !
  /// Is the current frame a key frame.
  @ffi.Int()
  external int is_key_frame;

  /// !
  /// Does the previous gop use alt ref or not.
  @ffi.Int()
  external int last_gop_use_alt_ref;

  /// !
  /// Current frame distance to the last keyframe, e.g., if Nth frame is a key,
  /// then the value of the N+1 th frame is 1.
  @ffi.Int()
  external int frames_since_key;

  /// !
  /// Current frame distance to the next keyframe, e.g. if Nth frame is a key,
  /// then the value of frame N - 1 is 1.
  @ffi.Int()
  external int frames_to_key;

  /// !
  /// Number of lookahead source frames.
  @ffi.Int()
  external int lag_in_frames;

  /// !
  /// Display index (temporal stamp) of this frame in the whole clip,
  /// starts from zero.
  @ffi.Int()
  external int show_index;

  /// !
  /// Coding index of this frame in the whole clip, starts from zero.
  @ffi.Int()
  external int coding_index;

  /// !
  /// The index of the current gop, starts from zero, resets to zero
  /// when a keyframe is set.
  @ffi.Int()
  external int gop_global_index;
}

/// !\brief Information passed to the external rate control model to
/// help make GOP decisions.
typedef vpx_rc_gop_info_t = vpx_rc_gop_info;

/// !\brief The decision made by the external rate control model to set the
/// group of picture.
final class vpx_rc_gop_decision extends ffi.Struct {
  /// < The number of frames of this GOP
  @ffi.Int()
  external int gop_coding_frames;

  /// < Whether to use alt ref for this GOP
  @ffi.Int()
  external int use_alt_ref;
}

/// !\brief The decision made by the external rate control model to set the
/// group of picture.
typedef vpx_rc_gop_decision_t = vpx_rc_gop_decision;
typedef vpx_rc_create_model_cb_fn_tFunction = ffi.UnsignedInt Function(
    ffi.Pointer<ffi.Void> priv,
    ffi.Pointer<vpx_rc_config_t> ratectrl_config,
    ffi.Pointer<vpx_rc_model_t> rate_ctrl_model_ptr);
typedef Dartvpx_rc_create_model_cb_fn_tFunction = vpx_rc_status Function(
    ffi.Pointer<ffi.Void> priv,
    ffi.Pointer<vpx_rc_config_t> ratectrl_config,
    ffi.Pointer<vpx_rc_model_t> rate_ctrl_model_ptr);

/// !\brief Create an external rate control model callback prototype
///
/// This callback is invoked by the encoder to create an external rate control
/// model.
///
/// \param[in]  priv                Callback's private data
/// \param[in]  ratectrl_config     Pointer to vpx_rc_config_t
/// \param[out] rate_ctrl_model_ptr Pointer to vpx_rc_model_t
typedef vpx_rc_create_model_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_rc_create_model_cb_fn_tFunction>>;
typedef vpx_rc_send_firstpass_stats_cb_fn_tFunction = ffi.UnsignedInt Function(
    vpx_rc_model_t rate_ctrl_model,
    ffi.Pointer<vpx_rc_firstpass_stats_t> first_pass_stats);
typedef Dartvpx_rc_send_firstpass_stats_cb_fn_tFunction
    = vpx_rc_status Function(vpx_rc_model_t rate_ctrl_model,
        ffi.Pointer<vpx_rc_firstpass_stats_t> first_pass_stats);

/// !\brief Send first pass stats to the external rate control model callback
/// prototype
///
/// This callback is invoked by the encoder to send first pass stats to the
/// external rate control model.
///
/// \param[in]  rate_ctrl_model    rate control model
/// \param[in]  first_pass_stats   first pass stats
typedef vpx_rc_send_firstpass_stats_cb_fn_t = ffi
    .Pointer<ffi.NativeFunction<vpx_rc_send_firstpass_stats_cb_fn_tFunction>>;
typedef vpx_rc_send_tpl_gop_stats_cb_fn_tFunction = ffi.UnsignedInt Function(
    vpx_rc_model_t rate_ctrl_model, ffi.Pointer<VpxTplGopStats> tpl_gop_stats);
typedef Dartvpx_rc_send_tpl_gop_stats_cb_fn_tFunction = vpx_rc_status Function(
    vpx_rc_model_t rate_ctrl_model, ffi.Pointer<VpxTplGopStats> tpl_gop_stats);

/// !\brief Send TPL stats for the current GOP to the external rate control model
/// callback prototype
///
/// This callback is invoked by the encoder to send TPL stats for the GOP to the
/// external rate control model.
///
/// \param[in]  rate_ctrl_model  rate control model
/// \param[in]  tpl_gop_stats    TPL stats for current GOP
typedef vpx_rc_send_tpl_gop_stats_cb_fn_t = ffi
    .Pointer<ffi.NativeFunction<vpx_rc_send_tpl_gop_stats_cb_fn_tFunction>>;
typedef vpx_rc_get_encodeframe_decision_cb_fn_tFunction
    = ffi.UnsignedInt Function(
        vpx_rc_model_t rate_ctrl_model,
        ffi.Pointer<vpx_rc_encodeframe_info_t> encode_frame_info,
        ffi.Pointer<vpx_rc_encodeframe_decision_t> frame_decision);
typedef Dartvpx_rc_get_encodeframe_decision_cb_fn_tFunction
    = vpx_rc_status Function(
        vpx_rc_model_t rate_ctrl_model,
        ffi.Pointer<vpx_rc_encodeframe_info_t> encode_frame_info,
        ffi.Pointer<vpx_rc_encodeframe_decision_t> frame_decision);

/// !\brief Receive encode frame decision callback prototype
///
/// This callback is invoked by the encoder to receive encode frame decision from
/// the external rate control model.
///
/// \param[in]  rate_ctrl_model    rate control model
/// \param[in]  encode_frame_info  information of the coding frame
/// \param[out] frame_decision     encode decision of the coding frame
typedef vpx_rc_get_encodeframe_decision_cb_fn_t = ffi.Pointer<
    ffi.NativeFunction<vpx_rc_get_encodeframe_decision_cb_fn_tFunction>>;
typedef vpx_rc_update_encodeframe_result_cb_fn_tFunction
    = ffi.UnsignedInt Function(vpx_rc_model_t rate_ctrl_model,
        ffi.Pointer<vpx_rc_encodeframe_result_t> encode_frame_result);
typedef Dartvpx_rc_update_encodeframe_result_cb_fn_tFunction
    = vpx_rc_status Function(vpx_rc_model_t rate_ctrl_model,
        ffi.Pointer<vpx_rc_encodeframe_result_t> encode_frame_result);

/// !\brief Update encode frame result callback prototype
///
/// This callback is invoked by the encoder to update encode frame result to the
/// external rate control model.
///
/// \param[in]  rate_ctrl_model     rate control model
/// \param[out] encode_frame_result encode result of the coding frame
typedef vpx_rc_update_encodeframe_result_cb_fn_t = ffi.Pointer<
    ffi.NativeFunction<vpx_rc_update_encodeframe_result_cb_fn_tFunction>>;
typedef vpx_rc_get_gop_decision_cb_fn_tFunction = ffi.UnsignedInt Function(
    vpx_rc_model_t rate_ctrl_model,
    ffi.Pointer<vpx_rc_gop_info_t> gop_info,
    ffi.Pointer<vpx_rc_gop_decision_t> gop_decision);
typedef Dartvpx_rc_get_gop_decision_cb_fn_tFunction = vpx_rc_status Function(
    vpx_rc_model_t rate_ctrl_model,
    ffi.Pointer<vpx_rc_gop_info_t> gop_info,
    ffi.Pointer<vpx_rc_gop_decision_t> gop_decision);

/// !\brief Get the GOP structure from the external rate control model.
///
/// This callback is invoked by the encoder to get GOP decisions from
/// the external rate control model.
///
/// \param[in]  rate_ctrl_model  rate control model
/// \param[in]  gop_info         information collected from the encoder
/// \param[out] gop_decision     GOP decision from the model
typedef vpx_rc_get_gop_decision_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_rc_get_gop_decision_cb_fn_tFunction>>;
typedef vpx_rc_get_frame_rdmult_cb_fn_tFunction = ffi.UnsignedInt Function(
    vpx_rc_model_t rate_ctrl_model,
    ffi.Pointer<vpx_rc_encodeframe_info_t> frame_info,
    ffi.Pointer<ffi.Int> rdmult);
typedef Dartvpx_rc_get_frame_rdmult_cb_fn_tFunction = vpx_rc_status Function(
    vpx_rc_model_t rate_ctrl_model,
    ffi.Pointer<vpx_rc_encodeframe_info_t> frame_info,
    ffi.Pointer<ffi.Int> rdmult);

/// !\brief Get the frame rdmult from the external rate control model.
///
/// This callback is invoked by the encoder to get rdmult from
/// the external rate control model.
///
/// \param[in]  rate_ctrl_model  rate control model
/// \param[in]  frame_info       information collected from the encoder
/// \param[out] rdmult           frame rate-distortion multiplier from the model
typedef vpx_rc_get_frame_rdmult_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_rc_get_frame_rdmult_cb_fn_tFunction>>;
typedef vpx_rc_delete_model_cb_fn_tFunction = ffi.UnsignedInt Function(
    vpx_rc_model_t rate_ctrl_model);
typedef Dartvpx_rc_delete_model_cb_fn_tFunction = vpx_rc_status Function(
    vpx_rc_model_t rate_ctrl_model);

/// !\brief Delete the external rate control model callback prototype
///
/// This callback is invoked by the encoder to delete the external rate control
/// model.
///
/// \param[in]  rate_ctrl_model     rate control model
typedef vpx_rc_delete_model_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_rc_delete_model_cb_fn_tFunction>>;

/// !\brief Callback function set for external rate control.
///
/// The user can enable external rate control by registering
/// a set of callback functions with the codec control flag
/// VP9E_SET_EXTERNAL_RATE_CONTROL.
final class vpx_rc_funcs extends ffi.Struct {
  /// !
  /// The rate control type of this API.
  @ffi.UnsignedInt()
  external int rc_typeAsInt;

  vpx_rc_type get rc_type => vpx_rc_type.fromValue(rc_typeAsInt);

  /// !
  /// Create an external rate control model.
  external vpx_rc_create_model_cb_fn_t create_model;

  /// !
  /// Send first pass stats to the external rate control model.
  external vpx_rc_send_firstpass_stats_cb_fn_t send_firstpass_stats;

  /// !
  /// Send TPL stats for current GOP to the external rate control model.
  external vpx_rc_send_tpl_gop_stats_cb_fn_t send_tpl_gop_stats;

  /// !
  /// Get encodeframe decision from the external rate control model.
  external vpx_rc_get_encodeframe_decision_cb_fn_t get_encodeframe_decision;

  /// !
  /// Update encodeframe result to the external rate control model.
  external vpx_rc_update_encodeframe_result_cb_fn_t update_encodeframe_result;

  /// !
  /// Get GOP decisions from the external rate control model.
  external vpx_rc_get_gop_decision_cb_fn_t get_gop_decision;

  /// !
  /// Get rdmult for the frame from the external rate control model.
  external vpx_rc_get_frame_rdmult_cb_fn_t get_frame_rdmult;

  /// !
  /// Delete the external rate control model.
  external vpx_rc_delete_model_cb_fn_t delete_model;

  /// !
  /// Private data for the external rate control model.
  external ffi.Pointer<ffi.Void> priv;
}

/// !\brief Callback function set for external rate control.
///
/// The user can enable external rate control by registering
/// a set of callback functions with the codec control flag
/// VP9E_SET_EXTERNAL_RATE_CONTROL.
typedef vpx_rc_funcs_t = vpx_rc_funcs;

/// !\brief Time Stamp Type
///
/// An integer, which when multiplied by the stream's time base, provides
/// the absolute time of a sample.
typedef vpx_codec_pts_t = ffi.Int64;
typedef Dartvpx_codec_pts_t = int;

/// !\brief Compressed Frame Flags
///
/// This type represents a bitfield containing information about a compressed
/// frame that may be useful to an application. The most significant 16 bits
/// can be used by an algorithm to provide additional detail, for example to
/// support frame types that are codec specific (MPEG-1 D-frames for example)
typedef vpx_codec_frame_flags_t = ffi.Uint32;
typedef Dartvpx_codec_frame_flags_t = int;

/// !\brief Encoder output packet variants
///
/// This enumeration lists the different kinds of data packets that can be
/// returned by calls to vpx_codec_get_cx_data(). Algorithms \ref MAY
/// extend this list to provide additional functionality.
enum vpx_codec_cx_pkt_kind {
  /// < Compressed video frame
  VPX_CODEC_CX_FRAME_PKT(0),

  /// < Two-pass statistics for this frame
  VPX_CODEC_STATS_PKT(1),

  /// < first pass mb statistics for this frame
  VPX_CODEC_FPMB_STATS_PKT(2),

  /// < PSNR statistics for this frame
  VPX_CODEC_PSNR_PKT(3),

  /// < Algorithm extensions
  VPX_CODEC_CUSTOM_PKT(256);

  final int value;
  const vpx_codec_cx_pkt_kind(this.value);

  static vpx_codec_cx_pkt_kind fromValue(int value) => switch (value) {
        0 => VPX_CODEC_CX_FRAME_PKT,
        1 => VPX_CODEC_STATS_PKT,
        2 => VPX_CODEC_FPMB_STATS_PKT,
        3 => VPX_CODEC_PSNR_PKT,
        256 => VPX_CODEC_CUSTOM_PKT,
        _ => throw ArgumentError(
            'Unknown value for vpx_codec_cx_pkt_kind: $value'),
      };
}

final class UnnamedStruct1 extends ffi.Struct {
  /// < compressed data buffer
  external ffi.Pointer<ffi.Void> buf;

  /// < length of compressed data
  @ffi.Size()
  external int sz;

  /// !\brief time stamp to show frame (in timebase units)
  @vpx_codec_pts_t()
  external int pts;

  /// !\brief duration to show frame (in timebase units)
  @ffi.UnsignedLong()
  external int duration;

  /// < flags for this frame
  @vpx_codec_frame_flags_t()
  external int flags;

  /// !\brief the partition id defines the decoding order of the partitions.
  /// Only applicable when "output partition" mode is enabled. First
  /// partition has id 0.
  @ffi.Int()
  external int partition_id;

  /// < frame width
  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> width;

  /// < frame height
  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> height;

  /// !\brief Flag to indicate if spatial layer frame in this packet is
  /// encoded or dropped. VP8 will always be set to 1.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint8> spatial_layer_encoded;
}

final class vpx_psnr_pkt extends ffi.Struct {
  /// < Number of samples, total/y/u/v
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> samples;

  /// < sum squared error, total/y/u/v
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint64> sse;

  /// < PSNR, total/y/u/v
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Double> psnr;
}

final class UnnamedUnion2 extends ffi.Union {
  /// < data for compressed frame packet
  external UnnamedStruct1 frame;

  /// < data for two-pass packet
  external vpx_fixed_buf_t twopass_stats;

  /// < first pass mb packet
  external vpx_fixed_buf_t firstpass_mb_stats;

  /// < data for PSNR packet
  external vpx_psnr_pkt psnr;

  /// < data for arbitrary packets
  external vpx_fixed_buf_t raw;

  /// < fixed sz
  @ffi.Array.multi([124])
  external ffi.Array<ffi.Char> pad;
}

/// !\brief Encoder output packet
///
/// This structure contains the different kinds of output data the encoder
/// may produce while compressing a frame.
final class vpx_codec_cx_pkt extends ffi.Struct {
  /// < packet variant
  @ffi.UnsignedInt()
  external int kindAsInt;

  vpx_codec_cx_pkt_kind get kind => vpx_codec_cx_pkt_kind.fromValue(kindAsInt);

  /// < packet data
  external UnnamedUnion2 data;
}

/// !\brief Encoder output packet
///
/// This structure contains the different kinds of output data the encoder
/// may produce while compressing a frame.
typedef vpx_codec_cx_pkt_t = vpx_codec_cx_pkt;
typedef vpx_codec_enc_output_cx_pkt_cb_fn_tFunction = ffi.Void Function(
    ffi.Pointer<vpx_codec_cx_pkt_t> pkt, ffi.Pointer<ffi.Void> user_data);
typedef Dartvpx_codec_enc_output_cx_pkt_cb_fn_tFunction = void Function(
    ffi.Pointer<vpx_codec_cx_pkt_t> pkt, ffi.Pointer<ffi.Void> user_data);

/// !\brief Encoder return output buffer callback
///
/// This callback function, when registered, returns with packets when each
/// spatial layer is encoded.
typedef vpx_codec_enc_output_cx_pkt_cb_fn_t = ffi
    .Pointer<ffi.NativeFunction<vpx_codec_enc_output_cx_pkt_cb_fn_tFunction>>;

/// !\brief Callback function pointer / user data pair storage
final class vpx_codec_enc_output_cx_cb_pair extends ffi.Struct {
  /// < Callback function
  external vpx_codec_enc_output_cx_pkt_cb_fn_t output_cx_pkt;

  /// < Pointer to private data
  external ffi.Pointer<ffi.Void> user_priv;
}

/// !\brief Callback function pointer / user data pair storage
typedef vpx_codec_priv_output_cx_pkt_cb_pair_t
    = vpx_codec_enc_output_cx_cb_pair;

/// !\brief Encoded Frame Flags
///
/// This type indicates a bitfield to be passed to vpx_codec_encode(), defining
/// per-frame boolean values. By convention, bits common to all codecs will be
/// named VPX_EFLAG_*, and bits specific to an algorithm will be named
/// /algo/_eflag_*. The lower order 16 bits are reserved for common use.
typedef vpx_enc_frame_flags_t = ffi.Long;
typedef Dartvpx_enc_frame_flags_t = int;

/// !\brief Encoder configuration structure
///
/// This structure contains the encoder settings that have common representations
/// across all codecs. This doesn't imply that all codecs support all features,
/// however.
typedef vpx_codec_enc_cfg_t = vpx_codec_enc_cfg;

/// !\brief  vp9 svc extra configure parameters
///
/// This defines max/min quantizers and scale factors for each layer
final class vpx_svc_parameters extends ffi.Struct {
  /// < Max Q for each layer
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> max_quantizers;

  /// < Min Q for each layer
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> min_quantizers;

  /// < Scaling factor-numerator
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> scaling_factor_num;

  /// < Scaling factor-denominator
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> scaling_factor_den;

  /// < Speed setting for each sl
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> speed_per_layer;

  /// < Temporal layering mode
  @ffi.Int()
  external int temporal_layering_mode;

  /// < Loopfilter ctrl for each sl
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> loopfilter_ctrl;
}

/// !\brief  vp9 svc extra configure parameters
///
/// This defines max/min quantizers and scale factors for each layer
typedef vpx_svc_extra_cfg_t = vpx_svc_parameters;

/// !\brief VPx encoder control functions
///
/// This set of macros define the control functions available for VPx
/// encoder interface.
///
/// \sa #vpx_codec_control
enum vp8e_enc_control_id {
  /// !\brief Codec control function to pass an ROI map to encoder.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_ROI_MAP(8),

  /// !\brief Codec control function to pass an Active map to encoder.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_ACTIVEMAP(9),

  /// !\brief Codec control function to set encoder scaling mode.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_SCALEMODE(11),

  /// !\brief Codec control function to set encoder internal speed settings.
  ///
  /// Changes in this value influences, among others, the encoder's selection
  /// of motion estimation methods. Values greater than 0 will increase encoder
  /// speed at the expense of quality.
  ///
  /// \note Valid range for VP8: -16..16
  /// \note Valid range for VP9: -9..9
  /// \note A negative value (-n) is treated as its absolute value (n) in VP9.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_CPUUSED(13),

  /// !\brief Codec control function to enable automatic use of arf frames.
  ///
  /// \note Valid range for VP8: 0..1
  /// \note Valid range for VP9: 0..6
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_ENABLEAUTOALTREF(14),

  /// !\brief control function to set noise sensitivity
  ///
  /// 0: off, 1: OnYOnly, 2: OnYUV,
  /// 3: OnYUVAggressive, 4: Adaptive
  ///
  /// Supported in codecs: VP8
  VP8E_SET_NOISE_SENSITIVITY(15),

  /// !\brief Codec control function to set higher sharpness at the expense
  /// of a lower PSNR.
  ///
  /// \note Valid range: 0..7
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_SHARPNESS(16),

  /// !\brief Codec control function to set the threshold for MBs treated static.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_STATIC_THRESHOLD(17),

  /// !\brief Codec control function to set the number of token partitions.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_TOKEN_PARTITIONS(18),

  /// !\brief Codec control function to get last quantizer chosen by the encoder.
  ///
  /// Return value uses internal quantizer scale defined by the codec.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_GET_LAST_QUANTIZER(19),

  /// !\brief Codec control function to get last quantizer chosen by the encoder.
  ///
  /// Return value uses the 0..63 scale as used by the rc_*_quantizer config
  /// parameters.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_GET_LAST_QUANTIZER_64(20),

  /// !\brief Codec control function to set the max no of frames to create arf.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_ARNR_MAXFRAMES(21),

  /// !\brief Codec control function to set the filter strength for the arf.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_ARNR_STRENGTH(22),

  /// !\deprecated control function to set the filter type to use for the arf.
  VP8E_SET_ARNR_TYPE(23),

  /// !\brief Codec control function to set visual tuning.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_TUNING(24),

  /// !\brief Codec control function to set constrained / constant quality level.
  ///
  /// \attention For this value to be used vpx_codec_enc_cfg_t::rc_end_usage must
  /// be set to #VPX_CQ or #VPX_Q
  /// \note Valid range: 0..63
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_CQ_LEVEL(25),

  /// !\brief Codec control function to set Max data rate for Intra frames.
  ///
  /// This value controls additional clamping on the maximum size of a
  /// keyframe. It is expressed as a percentage of the average
  /// per-frame bitrate, with the special (and default) value 0 meaning
  /// unlimited, or no additional clamping beyond the codec's built-in
  /// algorithm.
  ///
  /// For example, to allocate no more than 4.5 frames worth of bitrate
  /// to a keyframe, set this to 450.
  ///
  /// Supported in codecs: VP8, VP9
  VP8E_SET_MAX_INTRA_BITRATE_PCT(26),

  /// !\brief Codec control function to set reference and update frame flags.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_FRAME_FLAGS(27),

  /// !\brief Codec control function to set max data rate for Inter frames.
  ///
  /// This value controls additional clamping on the maximum size of an
  /// inter frame. It is expressed as a percentage of the average
  /// per-frame bitrate, with the special (and default) value 0 meaning
  /// unlimited, or no additional clamping beyond the codec's built-in
  /// algorithm.
  ///
  /// For example, to allow no more than 4.5 frames worth of bitrate
  /// to an inter frame, set this to 450.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_MAX_INTER_BITRATE_PCT(28),

  /// !\brief Boost percentage for Golden Frame in CBR mode.
  ///
  /// This value controls the amount of boost given to Golden Frame in
  /// CBR mode. It is expressed as a percentage of the average
  /// per-frame bitrate, with the special (and default) value 0 meaning
  /// the feature is off, i.e., no golden frame boost in CBR mode and
  /// average bitrate target is used.
  ///
  /// For example, to allow 100% more bits, i.e., 2X, in a golden frame
  /// than average frame, set this to 100.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_GF_CBR_BOOST_PCT(29),

  /// !\brief Codec control function to set the temporal layer id.
  ///
  /// For temporal scalability: this control allows the application to set the
  /// layer id for each frame to be encoded. Note that this control must be set
  /// for every frame prior to encoding. The usage of this control function
  /// supersedes the internal temporal pattern counter, which is now deprecated.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_TEMPORAL_LAYER_ID(30),

  /// !\brief Codec control function to set encoder screen content mode.
  ///
  /// 0: off, 1: On, 2: On with more aggressive rate control.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_SCREEN_CONTENT_MODE(31),

  /// !\brief Codec control function to set lossless encoding mode.
  ///
  /// VP9 can operate in lossless encoding mode, in which the bitstream
  /// produced will be able to decode and reconstruct a perfect copy of
  /// input source. This control function provides a mean to switch encoder
  /// into lossless coding mode(1) or normal coding mode(0) that may be lossy.
  /// 0 = lossy coding mode
  /// 1 = lossless coding mode
  ///
  /// By default, encoder operates in normal coding mode (maybe lossy).
  ///
  /// Supported in codecs: VP9
  VP9E_SET_LOSSLESS(32),

  /// !\brief Codec control function to set number of tile columns.
  ///
  /// In encoding and decoding, VP9 allows an input image frame be partitioned
  /// into separated vertical tile columns, which can be encoded or decoded
  /// independently. This enables easy implementation of parallel encoding and
  /// decoding. This control requests the encoder to use column tiles in
  /// encoding an input frame, with number of tile columns (in Log2 unit) as
  /// the parameter:
  /// 0 = 1 tile column
  /// 1 = 2 tile columns
  /// 2 = 4 tile columns
  /// .....
  /// n = 2**n tile columns
  /// The requested tile columns will be capped by the encoder based on image
  /// size limitations (The minimum width of a tile column is 256 pixels, the
  /// maximum is 4096).
  ///
  /// By default, the value is 6, i.e., the maximum number of tiles supported by
  /// the resolution.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_TILE_COLUMNS(33),

  /// !\brief Codec control function to set number of tile rows.
  ///
  /// In encoding and decoding, VP9 allows an input image frame be partitioned
  /// into separated horizontal tile rows. Tile rows are encoded or decoded
  /// sequentially. Even though encoding/decoding of later tile rows depends on
  /// earlier ones, this allows the encoder to output data packets for tile rows
  /// prior to completely processing all tile rows in a frame, thereby reducing
  /// the latency in processing between input and output. The parameter
  /// for this control describes the number of tile rows, which has a valid
  /// range [0, 2]:
  /// 0 = 1 tile row
  /// 1 = 2 tile rows
  /// 2 = 4 tile rows
  ///
  /// By default, the value is 0, i.e. one single row tile for entire image.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_TILE_ROWS(34),

  /// !\brief Codec control function to enable frame parallel decoding feature.
  ///
  /// VP9 has a bitstream feature to reduce decoding dependency between frames
  /// by turning off backward update of probability context used in encoding
  /// and decoding. This allows staged parallel processing of more than one
  /// video frame in the decoder. This control function provides a means to
  /// turn this feature on or off for bitstreams produced by encoder.
  ///
  /// By default, this feature is on.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_FRAME_PARALLEL_DECODING(35),

  /// !\brief Codec control function to set adaptive quantization mode.
  ///
  /// VP9 has a segment based feature that allows encoder to adaptively change
  /// quantization parameter for each segment within a frame to improve the
  /// subjective quality. This control makes encoder operate in one of the
  /// several AQ_modes supported.
  ///
  /// By default, encoder operates with AQ_Mode 0(adaptive quantization off).
  ///
  /// Supported in codecs: VP9
  VP9E_SET_AQ_MODE(36),

  /// !\brief Codec control function to enable/disable periodic Q boost.
  ///
  /// One VP9 encoder speed feature is to enable quality boost by lowering
  /// frame level Q periodically. This control function provides a mean to
  /// turn on/off this feature.
  /// 0 = off
  /// 1 = on
  ///
  /// By default, the encoder is allowed to use this feature for appropriate
  /// encoding modes.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_FRAME_PERIODIC_BOOST(37),

  /// !\brief Codec control function to set noise sensitivity.
  ///
  /// 0: off, 1: On(YOnly), 2: For SVC only, on top two spatial layers(YOnly)
  ///
  /// Supported in codecs: VP9
  VP9E_SET_NOISE_SENSITIVITY(38),

  /// !\brief Codec control function to turn on/off SVC in encoder.
  /// \note Return value is VPX_CODEC_INVALID_PARAM if the encoder does not
  /// support SVC in its current encoding mode
  /// 0: off, 1: on
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC(39),

  /// !\brief Codec control function to pass an ROI map to encoder.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_ROI_MAP(40),

  /// !\brief Codec control function to set parameters for SVC.
  /// \note Parameters contain min_q, max_q, scaling factor for each of the
  /// SVC layers.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_PARAMETERS(41),

  /// !\brief Codec control function to set svc layer for spatial and temporal.
  /// \note Valid ranges: 0..#vpx_codec_enc_cfg::ss_number_layers for spatial
  /// layer and 0..#vpx_codec_enc_cfg::ts_number_layers for
  /// temporal layer.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_LAYER_ID(42),

  /// !\brief Codec control function to set content type.
  /// \note Valid parameter range:
  /// VP9E_CONTENT_DEFAULT = Regular video content (Default)
  /// VP9E_CONTENT_SCREEN  = Screen capture content
  /// VP9E_CONTENT_FILM    = Film content: improves grain retention
  ///
  /// Supported in codecs: VP9
  VP9E_SET_TUNE_CONTENT(43),

  /// !\brief Codec control function to get svc layer ID.
  /// \note The layer ID returned is for the data packet from the registered
  /// callback function.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_SVC_LAYER_ID(44),

  /// !\brief Codec control function to register callback to get per layer packet.
  /// \note Parameter for this control function is a structure with a callback
  /// function and a pointer to private data used by the callback.
  ///
  /// Supported in codecs: VP9
  VP9E_REGISTER_CX_CALLBACK(45),

  /// !\brief Codec control function to set color space info.
  /// \note Valid ranges: 0..7, default is "UNKNOWN".
  /// 0 = UNKNOWN,
  /// 1 = BT_601
  /// 2 = BT_709
  /// 3 = SMPTE_170
  /// 4 = SMPTE_240
  /// 5 = BT_2020
  /// 6 = RESERVED
  /// 7 = SRGB
  ///
  /// Supported in codecs: VP9
  VP9E_SET_COLOR_SPACE(46),

  /// !\brief Codec control function to set minimum interval between GF/ARF frames
  ///
  /// By default the value is set as 4.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_MIN_GF_INTERVAL(48),

  /// !\brief Codec control function to set minimum interval between GF/ARF frames
  ///
  /// By default the value is set as 16.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_MAX_GF_INTERVAL(49),

  /// !\brief Codec control function to get an Active map back from the encoder.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_ACTIVEMAP(50),

  /// !\brief Codec control function to set color range bit.
  /// \note Valid ranges: 0..1, default is 0
  /// 0 = Limited range (16..235 or HBD equivalent)
  /// 1 = Full range (0..255 or HBD equivalent)
  ///
  /// Supported in codecs: VP9
  VP9E_SET_COLOR_RANGE(51),

  /// !\brief Codec control function to set the frame flags and buffer indices
  /// for spatial layers. The frame flags and buffer indices are set using the
  /// struct #vpx_svc_ref_frame_config defined below.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_REF_FRAME_CONFIG(52),

  /// !\brief Codec control function to set intended rendering image size.
  ///
  /// By default, this is identical to the image size in pixels.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_RENDER_SIZE(53),

  /// !\brief Codec control function to set target level.
  ///
  /// 255: off (default); 0: only keep level stats; 10: target for level 1.0;
  /// 11: target for level 1.1; ... 62: target for level 6.2
  ///
  /// Supported in codecs: VP9
  VP9E_SET_TARGET_LEVEL(54),

  /// !\brief Codec control function to set row level multi-threading.
  ///
  /// 0 : off, 1 : on
  ///
  /// Supported in codecs: VP9
  VP9E_SET_ROW_MT(55),

  /// !\brief Codec control function to get bitstream level.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_LEVEL(56),

  /// !\brief Codec control function to enable/disable special mode for altref
  /// adaptive quantization. You can use it with --aq-mode concurrently.
  ///
  /// Enable special adaptive quantization for altref frames based on their
  /// expected prediction quality for the future frames.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_ALT_REF_AQ(57),

  /// !\brief Boost percentage for Golden Frame in CBR mode.
  ///
  /// This value controls the amount of boost given to Golden Frame in
  /// CBR mode. It is expressed as a percentage of the average
  /// per-frame bitrate, with the special (and default) value 0 meaning
  /// the feature is off, i.e., no golden frame boost in CBR mode and
  /// average bitrate target is used.
  ///
  /// For example, to allow 100% more bits, i.e., 2X, in a golden frame
  /// than average frame, set this to 100.
  ///
  /// Supported in codecs: VP8
  VP8E_SET_GF_CBR_BOOST_PCT(58),

  /// !\brief Codec control function to enable the extreme motion vector unit test
  /// in VP9. Please note that this is only used in motion vector unit test.
  ///
  /// 0 : off, 1 : MAX_EXTREME_MV, 2 : MIN_EXTREME_MV
  ///
  /// Supported in codecs: VP9
  VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(59),

  /// !\brief Codec control function to constrain the inter-layer prediction
  /// (prediction of lower spatial resolution) in VP9 SVC.
  ///
  /// 0 : inter-layer prediction on, 1 : off, 2 : off only on non-key frames
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_INTER_LAYER_PRED(60),

  /// !\brief Codec control function to set mode and thresholds for frame
  /// dropping in SVC. Drop frame thresholds are set per-layer. Mode is set as:
  /// 0 : layer-dependent dropping, 1 : constrained dropping, current layer drop
  /// forces drop on all upper layers. Default mode is 0.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_FRAME_DROP_LAYER(61),

  /// !\brief Codec control function to get the refresh and reference flags and
  /// the buffer indices, up to the last encoded spatial layer.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_SVC_REF_FRAME_CONFIG(62),

  /// !\brief Codec control function to enable/disable use of golden reference as
  /// a second temporal reference for SVC. Only used when inter-layer prediction
  /// is disabled on INTER frames.
  ///
  /// 0: Off, 1: Enabled (default)
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_GF_TEMPORAL_REF(63),

  /// !\brief Codec control function to enable spatial layer sync frame, for any
  /// spatial layer. Enabling it for layer k means spatial layer k will disable
  /// all temporal prediction, but keep the inter-layer prediction. It will
  /// refresh any temporal reference buffer for that layer, and reset the
  /// temporal layer for the superframe to 0. Setting the layer sync for base
  /// spatial layer forces a key frame. Default is off (0) for all spatial
  /// layers. Spatial layer sync flag is reset to 0 after each encoded layer,
  /// so when control is invoked it is only used for the current superframe.
  ///
  /// 0: Off (default), 1: Enabled
  ///
  /// Supported in codecs: VP9
  VP9E_SET_SVC_SPATIAL_LAYER_SYNC(64),

  /// !\brief Codec control function to enable temporal dependency model.
  ///
  /// Vp9 allows the encoder to run temporal dependency model and use it to
  /// improve the compression performance. To enable, set this parameter to be
  /// 1. The default value is set to be 1.
  VP9E_SET_TPL(65),

  /// !\brief Codec control function to enable postencode frame drop.
  ///
  /// This will allow encoder to drop frame after it's encoded.
  ///
  /// 0: Off (default), 1: Enabled
  ///
  /// Supported in codecs: VP9
  VP9E_SET_POSTENCODE_DROP(66),

  /// !\brief Codec control function to set delta q for uv.
  ///
  /// Cap it at +/-15.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_DELTA_Q_UV(67),

  /// !\brief Codec control function to disable increase Q on overshoot in CBR.
  ///
  /// 0: On (default), 1: Disable.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(68),

  /// !\brief Codec control function to disable loopfilter.
  ///
  /// 0: Loopfilter on all frames, 1: Disable on non reference frames.
  /// 2: Disable on all frames.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_DISABLE_LOOPFILTER(69),

  /// !\brief Codec control function to enable external rate control library.
  ///
  /// args[0]: path of the rate control library
  ///
  /// args[1]: private config of the rate control library
  ///
  /// Supported in codecs: VP9
  VP9E_SET_EXTERNAL_RATE_CONTROL(70),

  /// !\brief Codec control to disable internal features in rate control.
  ///
  /// This will do 3 things, only for 1 pass:
  /// - Turn off low motion computation
  /// - Turn off gf update constraint on key frame frequency
  /// - Turn off content mode for cyclic refresh
  ///
  /// With those, the rate control is expected to work exactly the same as the
  /// interface provided in ratectrl_rtc.cc/h
  ///
  /// Supported in codecs: VP9
  VP9E_SET_RTC_EXTERNAL_RATECTRL(71),

  /// !\brief Codec control function to get loopfilter level in the encoder.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_LOOPFILTER_LEVEL(72),

  /// !\brief Codec control to get last quantizers for all spatial layers.
  ///
  /// Return value uses an array of internal quantizers scale defined by the
  /// codec, for all spatial layers.
  /// The size of the array passed in should be #VPX_SS_MAX_LAYERS.
  ///
  /// Supported in codecs: VP9
  VP9E_GET_LAST_QUANTIZER_SVC_LAYERS(73),

  /// !\brief Codec control to disable internal features in rate control.
  ///
  /// This will turn off cyclic refresh for vp8.
  ///
  /// With this, the rate control is expected to work exactly the same as the
  /// interface provided in vp8_ratectrl_rtc.cc/h
  ///
  /// Supported in codecs: VP8
  VP8E_SET_RTC_EXTERNAL_RATECTRL(74),

  /// !\brief Codec control to set quantizer for the next frame.
  ///
  /// This will turn off cyclic refresh. Only applicable to 1-pass without
  /// spatial layers.
  ///
  /// Supported in codecs: VP9
  VP9E_SET_QUANTIZER_ONE_PASS(75);

  final int value;
  const vp8e_enc_control_id(this.value);

  static vp8e_enc_control_id fromValue(int value) => switch (value) {
        8 => VP8E_SET_ROI_MAP,
        9 => VP8E_SET_ACTIVEMAP,
        11 => VP8E_SET_SCALEMODE,
        13 => VP8E_SET_CPUUSED,
        14 => VP8E_SET_ENABLEAUTOALTREF,
        15 => VP8E_SET_NOISE_SENSITIVITY,
        16 => VP8E_SET_SHARPNESS,
        17 => VP8E_SET_STATIC_THRESHOLD,
        18 => VP8E_SET_TOKEN_PARTITIONS,
        19 => VP8E_GET_LAST_QUANTIZER,
        20 => VP8E_GET_LAST_QUANTIZER_64,
        21 => VP8E_SET_ARNR_MAXFRAMES,
        22 => VP8E_SET_ARNR_STRENGTH,
        23 => VP8E_SET_ARNR_TYPE,
        24 => VP8E_SET_TUNING,
        25 => VP8E_SET_CQ_LEVEL,
        26 => VP8E_SET_MAX_INTRA_BITRATE_PCT,
        27 => VP8E_SET_FRAME_FLAGS,
        28 => VP9E_SET_MAX_INTER_BITRATE_PCT,
        29 => VP9E_SET_GF_CBR_BOOST_PCT,
        30 => VP8E_SET_TEMPORAL_LAYER_ID,
        31 => VP8E_SET_SCREEN_CONTENT_MODE,
        32 => VP9E_SET_LOSSLESS,
        33 => VP9E_SET_TILE_COLUMNS,
        34 => VP9E_SET_TILE_ROWS,
        35 => VP9E_SET_FRAME_PARALLEL_DECODING,
        36 => VP9E_SET_AQ_MODE,
        37 => VP9E_SET_FRAME_PERIODIC_BOOST,
        38 => VP9E_SET_NOISE_SENSITIVITY,
        39 => VP9E_SET_SVC,
        40 => VP9E_SET_ROI_MAP,
        41 => VP9E_SET_SVC_PARAMETERS,
        42 => VP9E_SET_SVC_LAYER_ID,
        43 => VP9E_SET_TUNE_CONTENT,
        44 => VP9E_GET_SVC_LAYER_ID,
        45 => VP9E_REGISTER_CX_CALLBACK,
        46 => VP9E_SET_COLOR_SPACE,
        48 => VP9E_SET_MIN_GF_INTERVAL,
        49 => VP9E_SET_MAX_GF_INTERVAL,
        50 => VP9E_GET_ACTIVEMAP,
        51 => VP9E_SET_COLOR_RANGE,
        52 => VP9E_SET_SVC_REF_FRAME_CONFIG,
        53 => VP9E_SET_RENDER_SIZE,
        54 => VP9E_SET_TARGET_LEVEL,
        55 => VP9E_SET_ROW_MT,
        56 => VP9E_GET_LEVEL,
        57 => VP9E_SET_ALT_REF_AQ,
        58 => VP8E_SET_GF_CBR_BOOST_PCT,
        59 => VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST,
        60 => VP9E_SET_SVC_INTER_LAYER_PRED,
        61 => VP9E_SET_SVC_FRAME_DROP_LAYER,
        62 => VP9E_GET_SVC_REF_FRAME_CONFIG,
        63 => VP9E_SET_SVC_GF_TEMPORAL_REF,
        64 => VP9E_SET_SVC_SPATIAL_LAYER_SYNC,
        65 => VP9E_SET_TPL,
        66 => VP9E_SET_POSTENCODE_DROP,
        67 => VP9E_SET_DELTA_Q_UV,
        68 => VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR,
        69 => VP9E_SET_DISABLE_LOOPFILTER,
        70 => VP9E_SET_EXTERNAL_RATE_CONTROL,
        71 => VP9E_SET_RTC_EXTERNAL_RATECTRL,
        72 => VP9E_GET_LOOPFILTER_LEVEL,
        73 => VP9E_GET_LAST_QUANTIZER_SVC_LAYERS,
        74 => VP8E_SET_RTC_EXTERNAL_RATECTRL,
        75 => VP9E_SET_QUANTIZER_ONE_PASS,
        _ =>
          throw ArgumentError('Unknown value for vp8e_enc_control_id: $value'),
      };
}

/// !\brief vpx 1-D scaling mode
///
/// This set of constants define 1-D vpx scaling modes
enum vpx_scaling_mode_1d {
  VP8E_NORMAL(0),
  VP8E_FOURFIVE(1),
  VP8E_THREEFIVE(2),
  VP8E_ONETWO(3);

  final int value;
  const vpx_scaling_mode_1d(this.value);

  static vpx_scaling_mode_1d fromValue(int value) => switch (value) {
        0 => VP8E_NORMAL,
        1 => VP8E_FOURFIVE,
        2 => VP8E_THREEFIVE,
        3 => VP8E_ONETWO,
        _ =>
          throw ArgumentError('Unknown value for vpx_scaling_mode_1d: $value'),
      };
}

/// !\brief Temporal layering mode enum for VP9 SVC.
///
/// This set of macros define the different temporal layering modes.
/// Supported codecs: VP9 (in SVC mode)
enum vp9e_temporal_layering_mode {
  /// !\brief No temporal layering.
  /// Used when only spatial layering is used.
  VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING(0),

  /// !\brief Bypass mode.
  /// Used when application needs to control temporal layering.
  /// This will only work when the number of spatial layers equals 1.
  VP9E_TEMPORAL_LAYERING_MODE_BYPASS(1),

  /// !\brief 0-1-0-1... temporal layering scheme with two temporal layers.
  VP9E_TEMPORAL_LAYERING_MODE_0101(2),

  /// !\brief 0-2-1-2... temporal layering scheme with three temporal layers.
  VP9E_TEMPORAL_LAYERING_MODE_0212(3);

  final int value;
  const vp9e_temporal_layering_mode(this.value);

  static vp9e_temporal_layering_mode fromValue(int value) => switch (value) {
        0 => VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING,
        1 => VP9E_TEMPORAL_LAYERING_MODE_BYPASS,
        2 => VP9E_TEMPORAL_LAYERING_MODE_0101,
        3 => VP9E_TEMPORAL_LAYERING_MODE_0212,
        _ => throw ArgumentError(
            'Unknown value for vp9e_temporal_layering_mode: $value'),
      };
}

/// !\brief  vpx region of interest map
///
/// These defines the data structures for the region of interest map
final class vpx_roi_map extends ffi.Struct {
  /// ! If ROI is enabled.
  @ffi.Uint8()
  external int enabled;

  /// ! An id between 0-3 (0-7 for vp9) for each 16x16 (8x8 for VP9)
  /// region within a frame.
  external ffi.Pointer<ffi.UnsignedChar> roi_map;

  /// < Number of rows.
  @ffi.UnsignedInt()
  external int rows;

  /// < Number of columns.
  @ffi.UnsignedInt()
  external int cols;

  /// < Quantizer deltas. Valid range: [-63, 63].
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> delta_q;

  /// < Loop filter deltas. Valid range: [-63, 63].
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> delta_lf;

  /// < Skip this block.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> skip;

  /// < Reference frame for this block.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> ref_frame;

  /// ! Static breakout threshold for each segment. Only used in VP8.
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> static_threshold;
}

/// !\brief  vpx region of interest map
///
/// These defines the data structures for the region of interest map
typedef vpx_roi_map_t = vpx_roi_map;

/// !\brief  vpx active region map
///
/// These defines the data structures for active region map
final class vpx_active_map extends ffi.Struct {
  /// !\brief specify an on (1) or off (0) each 16x16 region within a frame
  external ffi.Pointer<ffi.UnsignedChar> active_map;

  /// < number of rows
  @ffi.UnsignedInt()
  external int rows;

  /// < number of cols
  @ffi.UnsignedInt()
  external int cols;
}

/// !\brief  vpx active region map
///
/// These defines the data structures for active region map
typedef vpx_active_map_t = vpx_active_map;

/// !\brief  vpx image scaling mode
///
/// This defines the data structure for image scaling mode
final class vpx_scaling_mode extends ffi.Struct {
  /// < horizontal scaling mode
  @ffi.UnsignedInt()
  external int h_scaling_modeAsInt;

  vpx_scaling_mode_1d get h_scaling_mode =>
      vpx_scaling_mode_1d.fromValue(h_scaling_modeAsInt);

  /// < vertical scaling mode
  @ffi.UnsignedInt()
  external int v_scaling_modeAsInt;

  vpx_scaling_mode_1d get v_scaling_mode =>
      vpx_scaling_mode_1d.fromValue(v_scaling_modeAsInt);
}

/// !\brief  vpx image scaling mode
///
/// This defines the data structure for image scaling mode
typedef vpx_scaling_mode_t = vpx_scaling_mode;

/// !\brief VP8 token partition mode
///
/// This defines VP8 partitioning mode for compressed data, i.e., the number of
/// sub-streams in the bitstream. Used for parallelized decoding.
enum vp8e_token_partitions {
  VP8_ONE_TOKENPARTITION(0),
  VP8_TWO_TOKENPARTITION(1),
  VP8_FOUR_TOKENPARTITION(2),
  VP8_EIGHT_TOKENPARTITION(3);

  final int value;
  const vp8e_token_partitions(this.value);

  static vp8e_token_partitions fromValue(int value) => switch (value) {
        0 => VP8_ONE_TOKENPARTITION,
        1 => VP8_TWO_TOKENPARTITION,
        2 => VP8_FOUR_TOKENPARTITION,
        3 => VP8_EIGHT_TOKENPARTITION,
        _ => throw ArgumentError(
            'Unknown value for vp8e_token_partitions: $value'),
      };
}

/// !brief VP9 encoder content type
enum vp9e_tune_content {
  VP9E_CONTENT_DEFAULT(0),
  VP9E_CONTENT_SCREEN(1),
  VP9E_CONTENT_FILM(2),
  VP9E_CONTENT_INVALID(3);

  final int value;
  const vp9e_tune_content(this.value);

  static vp9e_tune_content fromValue(int value) => switch (value) {
        0 => VP9E_CONTENT_DEFAULT,
        1 => VP9E_CONTENT_SCREEN,
        2 => VP9E_CONTENT_FILM,
        3 => VP9E_CONTENT_INVALID,
        _ => throw ArgumentError('Unknown value for vp9e_tune_content: $value'),
      };
}

/// !\brief VP8 model tuning parameters
///
/// Changes the encoder to tune for certain types of input material.
enum vp8e_tuning {
  VP8_TUNE_PSNR(0),
  VP8_TUNE_SSIM(1);

  final int value;
  const vp8e_tuning(this.value);

  static vp8e_tuning fromValue(int value) => switch (value) {
        0 => VP8_TUNE_PSNR,
        1 => VP8_TUNE_SSIM,
        _ => throw ArgumentError('Unknown value for vp8e_tuning: $value'),
      };
}

/// !\brief  vp9 svc layer parameters
///
/// This defines the spatial and temporal layer id numbers for svc encoding.
/// This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and
/// temporal layer id for the current frame.
final class vpx_svc_layer_id extends ffi.Struct {
  /// < First spatial layer to start encoding.
  @ffi.Int()
  external int spatial_layer_id;

  /// < Temporal layer id number.
  @ffi.Int()
  external int temporal_layer_id;

  /// < Temp layer id.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> temporal_layer_id_per_spatial;
}

/// !\brief  vp9 svc layer parameters
///
/// This defines the spatial and temporal layer id numbers for svc encoding.
/// This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and
/// temporal layer id for the current frame.
typedef vpx_svc_layer_id_t = vpx_svc_layer_id;

/// !\brief vp9 svc frame flag parameters.
///
/// This defines the frame flags and buffer indices for each spatial layer for
/// svc encoding.
/// This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame
/// flags and buffer indices for each spatial layer for the current (super)frame.
final class vpx_svc_ref_frame_config extends ffi.Struct {
  /// < Last buffer index.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> lst_fb_idx;

  /// < Golden buffer index.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> gld_fb_idx;

  /// < Altref buffer index.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> alt_fb_idx;

  /// < Update reference frames.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> update_buffer_slot;

  /// < Update last.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> update_last;

  /// < Update golden.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> update_golden;

  /// < Update altref.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> update_alt_ref;

  /// < Last as reference.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> reference_last;

  /// < Golden as reference.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> reference_golden;

  /// < Altref as reference.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> reference_alt_ref;

  /// < Duration per spatial layer.
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int64> duration;
}

/// !\brief vp9 svc frame flag parameters.
///
/// This defines the frame flags and buffer indices for each spatial layer for
/// svc encoding.
/// This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame
/// flags and buffer indices for each spatial layer for the current (super)frame.
typedef vpx_svc_ref_frame_config_t = vpx_svc_ref_frame_config;

/// !\brief VP9 svc frame dropping mode.
///
/// This defines the frame drop mode for SVC.
enum SVC_LAYER_DROP_MODE {
  CONSTRAINED_LAYER_DROP(0),

  /// < Any spatial layer can drop.
  LAYER_DROP(1),

  /// < Only full superframe can drop.
  FULL_SUPERFRAME_DROP(2),
  CONSTRAINED_FROM_ABOVE_DROP(3);

  final int value;
  const SVC_LAYER_DROP_MODE(this.value);

  static SVC_LAYER_DROP_MODE fromValue(int value) => switch (value) {
        0 => CONSTRAINED_LAYER_DROP,
        1 => LAYER_DROP,
        2 => FULL_SUPERFRAME_DROP,
        3 => CONSTRAINED_FROM_ABOVE_DROP,
        _ =>
          throw ArgumentError('Unknown value for SVC_LAYER_DROP_MODE: $value'),
      };
}

/// !\brief vp9 svc frame dropping parameters.
///
/// This defines the frame drop thresholds for each spatial layer, and
/// the frame dropping mode: 0 = layer based frame dropping (default),
/// 1 = constrained dropping where current layer drop forces all upper
/// spatial layers to drop.
final class vpx_svc_frame_drop extends ffi.Struct {
  /// < Frame drop thresholds
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> framedrop_thresh;

  /// < Layer-based or constrained dropping.
  @ffi.UnsignedInt()
  external int framedrop_modeAsInt;

  SVC_LAYER_DROP_MODE get framedrop_mode =>
      SVC_LAYER_DROP_MODE.fromValue(framedrop_modeAsInt);

  /// < Maximum consecutive drops, for any layer.
  @ffi.Int()
  external int max_consec_drop;
}

/// !\brief vp9 svc frame dropping parameters.
///
/// This defines the frame drop thresholds for each spatial layer, and
/// the frame dropping mode: 0 = layer based frame dropping (default),
/// 1 = constrained dropping where current layer drop forces all upper
/// spatial layers to drop.
typedef vpx_svc_frame_drop_t = vpx_svc_frame_drop;

/// !\brief vp9 svc spatial layer sync parameters.
///
/// This defines the spatial layer sync flag, defined per spatial layer.
final class vpx_svc_spatial_layer_sync extends ffi.Struct {
  /// < Sync layer flags
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> spatial_layer_sync;

  /// < Flag for setting Intra-only frame on base
  @ffi.Int()
  external int base_layer_intra_only;
}

/// !\brief vp9 svc spatial layer sync parameters.
///
/// This defines the spatial layer sync flag, defined per spatial layer.
typedef vpx_svc_spatial_layer_sync_t = vpx_svc_spatial_layer_sync;

/// !\enum vp8_dec_control_id
/// \brief VP8 decoder control functions
///
/// This set of macros define the control functions available for the VP8
/// decoder interface.
///
/// \sa #vpx_codec_control
enum vp8_dec_control_id {
  /// control function to get info on which reference frames were updated
  /// by the last decode
  VP8D_GET_LAST_REF_UPDATES(256),

  /// check if the indicated frame is corrupted
  VP8D_GET_FRAME_CORRUPTED(257),

  /// control function to get info on which reference frames were used
  /// by the last decode
  VP8D_GET_LAST_REF_USED(258),

  /// decryption function to decrypt encoded buffer data immediately
  /// before decoding. Takes a vpx_decrypt_init, which contains
  /// a callback function and opaque context pointer.
  VPXD_SET_DECRYPTOR(259),

  /// control function to get the dimensions that the current frame is decoded
  /// at. This may be different to the intended display size for the frame as
  /// specified in the wrapper or frame header (see VP9D_GET_DISPLAY_SIZE).
  VP9D_GET_FRAME_SIZE(260),

  /// control function to get the current frame's intended display dimensions
  /// (as specified in the wrapper or frame header). This may be different to
  /// the decoded dimensions of this frame (see VP9D_GET_FRAME_SIZE).
  VP9D_GET_DISPLAY_SIZE(261),

  /// control function to get the bit depth of the stream.
  VP9D_GET_BIT_DEPTH(262),

  /// control function to set the byte alignment of the planes in the reference
  /// buffers. Valid values are power of 2, from 32 to 1024. A value of 0 sets
  /// legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly
  /// follows Y plane, and V plane directly follows U plane. Default value is 0.
  VP9_SET_BYTE_ALIGNMENT(263),

  /// control function to invert the decoding order to from right to left. The
  /// function is used in a test to confirm the decoding independence of tile
  /// columns. The function may be used in application where this order
  /// of decoding is desired.
  ///
  /// TODO(yaowu): Rework the unit test that uses this control, and in a future
  /// release, this test-only control shall be removed.
  VP9_INVERT_TILE_DECODE_ORDER(264),

  /// control function to set the skip loop filter flag. Valid values are
  /// integers. The decoder will skip the loop filter when its value is set to
  /// nonzero. If the loop filter is skipped the decoder may accumulate decode
  /// artifacts. The default value is 0.
  VP9_SET_SKIP_LOOP_FILTER(265),

  /// control function to decode SVC stream up to the x spatial layers,
  /// where x is passed in through the control, and is 0 for base layer.
  VP9_DECODE_SVC_SPATIAL_LAYER(266),

  /// !\brief Codec control function to get last decoded frame quantizer.
  ///
  /// Return value uses internal quantizer scale defined by the codec.
  ///
  /// Supported in codecs: VP8, VP9
  VPXD_GET_LAST_QUANTIZER(267),

  /// !\brief Codec control function to set row level multi-threading.
  ///
  /// 0 : off, 1 : on
  ///
  /// Supported in codecs: VP9
  VP9D_SET_ROW_MT(268),

  /// !\brief Codec control function to set loopfilter optimization.
  ///
  /// 0 : off, Loop filter is done after all tiles have been decoded
  /// 1 : on, Loop filter is done immediately after decode without
  /// waiting for all threads to sync.
  ///
  /// Supported in codecs: VP9
  VP9D_SET_LOOP_FILTER_OPT(269),
  VP8_DECODER_CTRL_ID_MAX(270);

  static const VP8D_SET_DECRYPTOR = VPXD_SET_DECRYPTOR;

  final int value;
  const vp8_dec_control_id(this.value);

  static vp8_dec_control_id fromValue(int value) => switch (value) {
        256 => VP8D_GET_LAST_REF_UPDATES,
        257 => VP8D_GET_FRAME_CORRUPTED,
        258 => VP8D_GET_LAST_REF_USED,
        259 => VPXD_SET_DECRYPTOR,
        260 => VP9D_GET_FRAME_SIZE,
        261 => VP9D_GET_DISPLAY_SIZE,
        262 => VP9D_GET_BIT_DEPTH,
        263 => VP9_SET_BYTE_ALIGNMENT,
        264 => VP9_INVERT_TILE_DECODE_ORDER,
        265 => VP9_SET_SKIP_LOOP_FILTER,
        266 => VP9_DECODE_SVC_SPATIAL_LAYER,
        267 => VPXD_GET_LAST_QUANTIZER,
        268 => VP9D_SET_ROW_MT,
        269 => VP9D_SET_LOOP_FILTER_OPT,
        270 => VP8_DECODER_CTRL_ID_MAX,
        _ =>
          throw ArgumentError('Unknown value for vp8_dec_control_id: $value'),
      };

  @override
  String toString() {
    if (this == VPXD_SET_DECRYPTOR)
      return "vp8_dec_control_id.VPXD_SET_DECRYPTOR, vp8_dec_control_id.VP8D_SET_DECRYPTOR";
    return super.toString();
  }
}

typedef vpx_decrypt_cbFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> decrypt_state,
    ffi.Pointer<ffi.UnsignedChar> input,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Int count);
typedef Dartvpx_decrypt_cbFunction = void Function(
    ffi.Pointer<ffi.Void> decrypt_state,
    ffi.Pointer<ffi.UnsignedChar> input,
    ffi.Pointer<ffi.UnsignedChar> output,
    int count);

/// Decrypt n bytes of data from input -> output, using the decrypt_state
/// passed in VPXD_SET_DECRYPTOR.
typedef vpx_decrypt_cb
    = ffi.Pointer<ffi.NativeFunction<vpx_decrypt_cbFunction>>;

/// !\brief Structure to hold decryption state
///
/// Defines a structure to hold the decryption state and access function.
final class vpx_decrypt_init extends ffi.Struct {
  /// ! Decrypt callback.
  external vpx_decrypt_cb decrypt_cb;

  /// ! Decryption state.
  external ffi.Pointer<ffi.Void> decrypt_state;
}

/// !\brief External frame buffer
///
/// This structure holds allocated frame buffers used by the decoder.
final class vpx_codec_frame_buffer extends ffi.Struct {
  /// < Pointer to the data buffer
  external ffi.Pointer<ffi.Uint8> data;

  /// < Size of data in bytes
  @ffi.Size()
  external int size;

  /// < Frame's private data
  external ffi.Pointer<ffi.Void> priv;
}

/// !\brief External frame buffer
///
/// This structure holds allocated frame buffers used by the decoder.
typedef vpx_codec_frame_buffer_t = vpx_codec_frame_buffer;
typedef vpx_get_frame_buffer_cb_fn_tFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> priv,
    ffi.Size min_size,
    ffi.Pointer<vpx_codec_frame_buffer_t> fb);
typedef Dartvpx_get_frame_buffer_cb_fn_tFunction = int Function(
    ffi.Pointer<ffi.Void> priv,
    int min_size,
    ffi.Pointer<vpx_codec_frame_buffer_t> fb);

/// !\brief get frame buffer callback prototype
///
/// This callback is invoked by the decoder to retrieve data for the frame
/// buffer in order for the decode call to complete. The callback must
/// allocate at least min_size in bytes and assign it to fb->data. The callback
/// must zero out all the data allocated. Then the callback must set fb->size
/// to the allocated size. The application does not need to align the allocated
/// data. The callback is triggered when the decoder needs a frame buffer to
/// decode a compressed image into. This function may be called more than once
/// for every call to vpx_codec_decode. The application may set fb->priv to
/// some data which will be passed back in the vpx_image_t and the release
/// function call. |fb| is guaranteed to not be NULL. On success the callback
/// must return 0. Any failure the callback must return a value less than 0.
///
/// \param[in] priv         Callback's private data
/// \param[in] min_size     Size in bytes needed by the buffer
/// \param[in,out] fb       Pointer to vpx_codec_frame_buffer_t
typedef vpx_get_frame_buffer_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_get_frame_buffer_cb_fn_tFunction>>;
typedef vpx_release_frame_buffer_cb_fn_tFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> priv, ffi.Pointer<vpx_codec_frame_buffer_t> fb);
typedef Dartvpx_release_frame_buffer_cb_fn_tFunction = int Function(
    ffi.Pointer<ffi.Void> priv, ffi.Pointer<vpx_codec_frame_buffer_t> fb);

/// !\brief release frame buffer callback prototype
///
/// This callback is invoked by the decoder when the frame buffer is not
/// referenced by any other buffers. |fb| is guaranteed to not be NULL. On
/// success the callback must return 0. Any failure the callback must return
/// a value less than 0.
///
/// \param[in] priv         Callback's private data
/// \param[in] fb           Pointer to vpx_codec_frame_buffer_t
typedef vpx_release_frame_buffer_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_release_frame_buffer_cb_fn_tFunction>>;

/// !\brief Stream properties
///
/// This structure is used to query or set properties of the decoded
/// stream. Algorithms may extend this structure with data specific
/// to their bitstream by setting the sz member appropriately.
final class vpx_codec_stream_info extends ffi.Struct {
  /// < Size of this structure
  @ffi.UnsignedInt()
  external int sz;

  /// < Width (or 0 for unknown/default)
  @ffi.UnsignedInt()
  external int w;

  /// < Height (or 0 for unknown/default)
  @ffi.UnsignedInt()
  external int h;

  /// < Current frame is a keyframe
  @ffi.UnsignedInt()
  external int is_kf;
}

/// !\brief Stream properties
///
/// This structure is used to query or set properties of the decoded
/// stream. Algorithms may extend this structure with data specific
/// to their bitstream by setting the sz member appropriately.
typedef vpx_codec_stream_info_t = vpx_codec_stream_info;

/// !\brief Initialization Configurations
///
/// This structure is used to pass init time configuration options to the
/// decoder.
typedef vpx_codec_dec_cfg_t = vpx_codec_dec_cfg;
typedef vpx_codec_put_frame_cb_fn_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> user_priv, ffi.Pointer<vpx_image_t> img);
typedef Dartvpx_codec_put_frame_cb_fn_tFunction = void Function(
    ffi.Pointer<ffi.Void> user_priv, ffi.Pointer<vpx_image_t> img);

/// !\brief put frame callback prototype
///
/// This callback is invoked by the decoder to notify the application of
/// the availability of decoded image data.
typedef vpx_codec_put_frame_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_codec_put_frame_cb_fn_tFunction>>;
typedef vpx_codec_put_slice_cb_fn_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> user_priv,
    ffi.Pointer<vpx_image_t> img,
    ffi.Pointer<vpx_image_rect_t> valid,
    ffi.Pointer<vpx_image_rect_t> update);
typedef Dartvpx_codec_put_slice_cb_fn_tFunction = void Function(
    ffi.Pointer<ffi.Void> user_priv,
    ffi.Pointer<vpx_image_t> img,
    ffi.Pointer<vpx_image_rect_t> valid,
    ffi.Pointer<vpx_image_rect_t> update);

/// !\brief put slice callback prototype
///
/// This callback is invoked by the decoder to notify the application of
/// the availability of partially decoded image data.
typedef vpx_codec_put_slice_cb_fn_t
    = ffi.Pointer<ffi.NativeFunction<vpx_codec_put_slice_cb_fn_tFunction>>;

const int VPX_IMAGE_ABI_VERSION = 5;

const int VPX_IMG_FMT_PLANAR = 256;

const int VPX_IMG_FMT_UV_FLIP = 512;

const int VPX_IMG_FMT_HAS_ALPHA = 1024;

const int VPX_IMG_FMT_HIGHBITDEPTH = 2048;

const int VPX_PLANE_PACKED = 0;

const int VPX_PLANE_Y = 0;

const int VPX_PLANE_U = 1;

const int VPX_PLANE_V = 2;

const int VPX_PLANE_ALPHA = 3;

const int VPX_CODEC_ABI_VERSION = 9;

const int VPX_CODEC_CAP_DECODER = 1;

const int VPX_CODEC_CAP_ENCODER = 2;

const int VPX_CODEC_CAP_HIGHBITDEPTH = 4;

const int VPX_TPL_ABI_VERSION = 2;

const int VPX_EXT_RATECTRL_ABI_VERSION = 7;

const int VPX_DEFAULT_Q = -1;

const int VPX_DEFAULT_RDMULT = -1;

const int VPX_TS_MAX_PERIODICITY = 16;

const int VPX_TS_MAX_LAYERS = 5;

const int VPX_MAX_LAYERS = 12;

const int VPX_SS_MAX_LAYERS = 5;

const int VPX_SS_DEFAULT_LAYERS = 1;

const int VPX_ENCODER_ABI_VERSION = 34;

const int VPX_CODEC_CAP_PSNR = 65536;

const int VPX_CODEC_CAP_OUTPUT_PARTITION = 131072;

const int VPX_CODEC_USE_PSNR = 65536;

const int VPX_CODEC_USE_OUTPUT_PARTITION = 131072;

const int VPX_CODEC_USE_HIGHBITDEPTH = 262144;

const int VPX_FRAME_IS_KEY = 1;

const int VPX_FRAME_IS_DROPPABLE = 2;

const int VPX_FRAME_IS_INVISIBLE = 4;

const int VPX_FRAME_IS_FRAGMENT = 8;

const int VPX_ERROR_RESILIENT_DEFAULT = 1;

const int VPX_ERROR_RESILIENT_PARTITIONS = 2;

const int VPX_EFLAG_FORCE_KF = 1;

const int VPX_DL_REALTIME = 1;

const int VPX_DL_GOOD_QUALITY = 1000000;

const int VPX_DL_BEST_QUALITY = 0;

const int VP8_EFLAG_NO_REF_LAST = 65536;

const int VP8_EFLAG_NO_REF_GF = 131072;

const int VP8_EFLAG_NO_REF_ARF = 2097152;

const int VP8_EFLAG_NO_UPD_LAST = 262144;

const int VP8_EFLAG_NO_UPD_GF = 4194304;

const int VP8_EFLAG_NO_UPD_ARF = 8388608;

const int VP8_EFLAG_FORCE_GF = 524288;

const int VP8_EFLAG_FORCE_ARF = 16777216;

const int VP8_EFLAG_NO_UPD_ENTROPY = 1048576;

const int VPX_MAXIMUM_WORK_BUFFERS = 8;

const int VP9_MAXIMUM_REF_BUFFERS = 8;

const int VPX_DECODER_ABI_VERSION = 12;

const int VPX_CODEC_CAP_PUT_SLICE = 65536;

const int VPX_CODEC_CAP_PUT_FRAME = 131072;

const int VPX_CODEC_CAP_POSTPROC = 262144;

const int VPX_CODEC_CAP_ERROR_CONCEALMENT = 524288;

const int VPX_CODEC_CAP_INPUT_FRAGMENTS = 1048576;

const int VPX_CODEC_CAP_FRAME_THREADING = 2097152;

const int VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER = 4194304;

const int VPX_CODEC_USE_POSTPROC = 65536;

const int VPX_CODEC_USE_ERROR_CONCEALMENT = 131072;

const int VPX_CODEC_USE_INPUT_FRAGMENTS = 262144;

const int VPX_CODEC_USE_FRAME_THREADING = 524288;
